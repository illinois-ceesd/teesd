<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JustKernels: Developer Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xpacc_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JustKernels
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">XPACC Multiphysics simluation application</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('developer_reference.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Developer Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The intent of this page is to provide some useful information about commonly used data structures and constructs in a centralized quick-reference.</p>
<h1><a class="anchor" id="config"></a>
Configuration Object</h1>
<p>PlasCom2 makes extensive use of a so-called <em>Configuration Object</em> which encapsulates user options and other information and makes it available far-and-wide to the code. The main configuration object (plascom2::application::appConfig) gets populated at application configuration time from (plascom2::application::ConfigureApplication). The configuration object type is essentially an (ix::util::Parameters) object which is just a collection of Key/Value pairs. Once populated, the configuration object is available to all processors at the top level of PlasCom2 scope.</p>
<p>If the user specified a configuration file on the command line (i.e. with the -c &lt;<em>ConfigFile</em>&gt; option), then that file is read into the configuration object. For restarts, the configuration object may be populated from the HDF5 restart file. Otherwise, not specifying a configuration will invoke <em>BareBones</em> mode and no simulation will be performed.</p>
<p>If the specified configuration is a legacy file (e.g. plascomcm.inp), then the configuration is translated into a PlasCom2-style configuration. The legacy part of the configuration is retained, but not used by PlasCom2.</p>
<h2><a class="anchor" id="configfile"></a>
Configuration Files</h2>
<p>The accepted format for configuration file lines is identical between PlasCom2 and PlasComCM. It is essentially:<br />
 </p><blockquote class="doxtable">
<p>Key = Value <br />
</p>
</blockquote>
<p>The primitive datatype is std::string for both <em>Key</em> and <em>Value</em>. The <em>Value</em> is read in as everything (excepting leading and trailing whitespace) that follows the "=" character until the end-of-line or a comment character, whichever comes first. Comments are started with the "#" character and anything between the comment character and the end-of-line is ignored. Lines beginning with comment characters are ignored.</p>
<p>The PlasCom2 configuration file format differs from the legacy PlasComCM <em>inp</em> format in that it supports the configuration of multiple simulation constructs (e.g. domains, grids, boundaries) through the use of <em>configuration scope specifyers</em>. Configuration scope is indicated through the <em>Key</em> with a "&lt;ScopeName&gt;:" format. For example the configuration line: <br />
</p><blockquote class="doxtable">
<p>Grid1:GridType = Curvlinear # grid is a general curvilinear grid<br />
</p>
</blockquote>
<p>In the above configuration line, the <em>Key</em> is "Grid1:GridType", the <em>Value</em> is "Curvilinear", and everything after the "#" is a comment. The <em>Key</em> indicates <em>Grid1</em> scope. Other grid configurations may be present in the configuration, and they will all have a "GridType" entry, but each will have its own scope. Everything that comes before the last ":" character is considered as a scope specification.</p>
<p>PlasCom2 configuration files can also be nested. Two forms of nesting are supported, <em>composition</em>, and <em>inheritance</em>.</p>
<h3><a class="anchor" id="configcomposition"></a>
Composition</h3>
<p>Composition nesting for configuration files is achieved with the <em>ConfigFile</em> keyword. For example:<br />
 </p><blockquote class="doxtable">
<p>XXX:YYY:ConfigFile = SomeOtherFile.config<br />
</p>
</blockquote>
<p>Any configuration Key that ends with the ConfigFile keyword will cause the configuration utility to find "SomeOtherFile.config" in a relative path and include it (i.e. the parameters it contains) in the configuration object.</p>
<h3><a class="anchor" id="configinheritance"></a>
Inheritance</h3>
<p>Inheritance nesting is accomplished with the <em>SubConfigFile</em> keyword. SubConfigFiles cause the file specified by the value of the configuration key to be parsed in a way that <em>inherits</em> the parent scope. For example:<br />
 </p><blockquote class="doxtable">
<p>XXX:YYY:SubConfigFile = SomeOtherFile.config<br />
</p>
</blockquote>
<p>Using the SubConfigFile keyword causes all parameters read from SomeOtherFile.config to inherit the XXX scope. Any subsequent SubConfigFile parameters will also inherit the parent scope.</p>
<h2><a class="anchor" id="configkey"></a>
Configuration Keys</h2>
<h2><a class="anchor" id="configvalue"></a>
Configuration Values</h2>
<h1><a class="anchor" id="state"></a>
State Object</h1>
<p>The PlasCom2 <em>State Object</em> (plascom2::simulation::state::base) centralizes and encapsulates all of the so-called heavy data of a given simulation. It inherits from the primitive field data type (pcpp::fielddata::dataset).</p>
<h2><a class="anchor" id="metadata"></a>
Field MetaData</h2>
<h2><a class="anchor" id="dictionary"></a>
Data Dictionary</h2>
<h1><a class="anchor" id="interval"></a>
Interval Object</h1>
<p>Information about grids, their domain decomposition, grid regions and sub-regions are stored in a <em>PlasCom2</em> data structure called an <em>interval</em>. The data type for the interval is ix::util::sizeextent. What the intervals do and how to use them is best illustrated by example. The following describes an example that is implemented in the TestPartitionIntervals() function in the file TestIntervals.C.</p>
<p>Example: Consider a logically rectangular domain (D) represented by the "interval":</p>
<blockquote class="doxtable">
<p>(D) = {1:NI,1:NJ,1:NK} </p>
</blockquote>
<div class="image">
<img src="DomainD_small.png" alt="DomainD_small.png"/>
<div class="caption">
The Domain (D) and Probe/ROI (R)</div></div>
<p>Also define rectangular "region of interest" in the domain (D) represented by the "probe interval" (R). The probe interval (R) is a sub-region of the global domain (D), and is specified as a subset of (D):</p>
<blockquote class="doxtable">
<p>(R) = {i1:i2,j1:j2,k1:k2}. </p>
</blockquote>
<p>Assume (D) has been decomposed into some number of logically rectangular non-overlapping partitions and distributed among processes, i.e. so that each process "owns" a partition or a rectangular subregion of (D). The rectangular subregion (a.k.a. the partition) is represented by the interval (L), and each processor's locally-owned piece of the domain has the local partition interval:</p>
<blockquote class="doxtable">
<p>(L) = {li1:li2,lj1:lj2,lk1:lk2}. </p>
</blockquote>
<div class="image">
<img src="DomainDecomp.png" alt="DomainDecomp.png"/>
<div class="caption">
Decomposed Domain</div></div>
<p>The size of each partition is (nI x nJ x nK) where:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> li1,li2,lj1,lj2,lk1,lk2; <span class="comment">// set by decomposition</span></div><div class="line"><span class="keywordtype">size_t</span> nI = (li2 - li1) + 1;  </div><div class="line"><span class="keywordtype">size_t</span> nJ = (lj2 - lj1) + 1;  </div><div class="line"><span class="keywordtype">size_t</span> nK = (lk2 - lk1) + 1; </div></div><!-- fragment --><p>The parallel application process will typically create a buffer that is larger than the partition in order to encapsulate a number of <em>halo</em> points who's data will be filled by communication with remote partitions. If the halo is (nH) points wide, then a buffer of size (nBi x nBj x nBk) is required to store data on each point of the partition and its halos, where on each process the required buffer size is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> nH;               <span class="comment">// halo size</span></div><div class="line"><span class="keywordtype">size_t</span> nI,nJ,nK;         <span class="comment">// from above</span></div><div class="line"><span class="keywordtype">size_t</span> nBi = (nI + 2*nH);</div><div class="line"><span class="keywordtype">size_t</span> nBj = (nJ + 2*nH);</div><div class="line"><span class="keywordtype">size_t</span> nBk = (nK + 2*nH);</div></div><!-- fragment --><p>This buffer size covers both your partition and the halo points on either side of the partition. Let (B) be the buffer interval:</p>
<blockquote class="doxtable">
<p>(B) = {1:nBi,1:nBj,1:nBk} </p>
</blockquote>
<div class="image">
<img src="PartitionBuffer.png" alt="PartitionBuffer.png"/>
<div class="caption">
Partition Buffer - with halos</div></div>
<p>The interval for (L) is called the "partition interval"; it's coordinates are with respect to the non-partitioned domain (D). That is, it has IJK values (aka coordinates) that are wrt the global, non-partitioned domain (D). The local buffer points corresponding to the points of your local partition interval (L) are referred to as the "partition buffer interval" (PBI). In this case with halos all around, the (PBI) is this interval:</p>
<blockquote class="doxtable">
<p>(PBI) = {nH+1:nH+nI,nH+1:nH+1:nH+nJ,nH+1:nH+nK} </p>
</blockquote>
<h2><a class="anchor" id="creation"></a>
Creating interval objects</h2>
<p>All of these "intervals" (R), (D), (L), (B) and (PBI) are represented by ix::util::sizeextent objects. They can be created by the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> domainSizes[]           = {NI,NJ,NK}; </div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="MetricKernels_8H.html#af0ac147fcc3cf0ebf0ce192160b920b2">bufferSizes</a>[]           = {nBi,nBj,nBk};</div><div class="line"><span class="keywordtype">size_t</span> flatPartitionInterval[] = {li1,li2,lj1,lj2,lk1,lk2};</div><div class="line"><span class="keywordtype">size_t</span> flatProbeInterval[]     = {i1,i2,j1,j2,k1,k2};      </div><div class="line"><span class="keywordtype">size_t</span> flatPartBuffInterval[]  = {nH+1,nH+nI,nH+1,nH+nJ,nH+1,nH+nK};</div><div class="line">                                                                    </div><div class="line">ix::util::sizeextent domainInterval, <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;                </div><div class="line">domainInterval.InitSimple(3,domainSizes);           <span class="comment">// (D)                    </span></div><div class="line">domainInterval.Fortranslate();                      <span class="comment">// use 1-based indices              </span></div><div class="line"><a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>.InitSimple(3,<a class="code" href="MetricKernels_8H.html#af0ac147fcc3cf0ebf0ce192160b920b2">bufferSizes</a>);           <span class="comment">// (B)                    </span></div><div class="line"><a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>.Fortranslate();                                      </div><div class="line">                                                                    </div><div class="line">ix::util::sizeextent probeInterval(flatProbeInterval,3);              <span class="comment">// (R) </span></div><div class="line">ix::util::sizeextent partitionInterval(flatPartitionInterval,3);      <span class="comment">// (L) </span></div><div class="line">ix::util::sizeextent partitionBufferInterval(flatPartBuffInterval,3); <span class="comment">// (PBI)</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Fortranslate is not needed by (R),(L),(PBI) - these were explicitly created by initializing with 1-based static intervals.</dd></dl>
<p>The capabilities of the interval datatype (i.e. ix::util::sizeextent) are demonstrated by answering these questions about the domain and region of interest:</p>
<ol type="1">
<li>What portion of the global probe interval (R) is located on the local partition?</li>
<li>What is the interval of the local buffer that corresponds to the locally owned part of (R)?</li>
<li>What are the buffer indices that correspond to the local probe points?</li>
<li>Given a local buffer index (l0):<ol type="a">
<li>what are the point's IJK coordinates wrt the local buffer (B)?</li>
<li>is the point in the halo or in the partition?</li>
<li>what are the point's IJK coordinates wrt the global domain (D)?</li>
<li>is the point within the region of interest (R)?</li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="overlap"></a>
Detecting overlap or collision of intervals</h2>
<h3>Question 1) What portion of the global probe interval (R) is located on the local partition?</h3>
<p>We need the extent to which (R) overlaps with (L), which we can get with the member function ix::util::sizeextent::Overlap. Here's how:</p>
<div class="fragment"><div class="line">ix::util::sizeextent partitionInterval; <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probeInterval;     <span class="comment">// from above </span></div><div class="line">ix::util::sizeextent probePartitionInterval(partitionInterval.Overlap(probeInterval)); </div></div><!-- fragment --><p><em>OR</em></p>
<div class="fragment"><div class="line">ix::util::sizeextent partitionInterval; <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probeInterval;     <span class="comment">// from above </span></div><div class="line">ix::util::sizeextent probePartitionInterval = partitionInterval.Overlap(probeInterval);            </div></div><!-- fragment --><p><em>OR</em></p>
<div class="fragment"><div class="line">ix::util::sizeextent partitionInterval; <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probeInterval;     <span class="comment">// from above </span></div><div class="line">ix::util::sizeextent probePartitionInterval;                                           </div><div class="line">partitionInterval.Overlap(probeInterval,probePartitionInterval);            </div></div><!-- fragment --><div class="image">
<img src="IntervalOverlap.png" alt="IntervalOverlap.png"/>
<div class="caption">
Overlap function returns the interval of the intersection of two input intervals.</div></div>
<p>Now (probePartitionInterval) is the part of the probe interval (R) that is owned locally.</p>
<h2><a class="anchor" id="translation"></a>
Relative translation of intervals</h2>
<h3>Question 2) What is the interval of my local buffer that corresponds to the locally-owned part of (R)?</h3>
<p>The local probe interval (probePartitionInterval) needs to be translated to line up with the storage buffer that includes the halo regions. That translation can be done with the member function ix::util::sizeextent::RelativeTranslation:</p>
<div class="fragment"><div class="line">ix::util::sizeextent probePartitionInterval;  <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent partitionBufferInterval; <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent partitionInterval;       <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probeBufferInterval;</div><div class="line">probePartitionInterval.RelativeTranslation(partitionInterval,partitionBufferInterval,probeBufferInterval);</div></div><!-- fragment --><div class="image">
<img src="RelativeTranslation.png" alt="RelativeTranslation.png"/>
<div class="caption">
Buffer interval for the sub-region corresponding to the locally-owned probe points </div></div>
<p>Now (probeBufferInterval) is the <em>buffer interval</em> that corresponds to the locally owned portion of the original probe interval (R). The action of RelativeTranslation is simply to find the offset of (probePartitionInterval) within (L) or (partitionInterval) and then translate it to the (PBI) or (partitionBufferInterval) interval.</p>
<div class="image">
<img src="BufferRegions.png" alt="BufferRegions.png"/>
<div class="caption">
The partition buffer with its sub-regions.</div></div>
<h2><a class="anchor" id="indices"></a>
Finding buffer indices for sub-intervals</h2>
<h3>Question 3) What are the buffer indices that correspond to the local probe points?</h3>
<p>These are the buffer indices that correspond to the (probeBufferInterval) interval. To get a vector of buffer indices that correspond to a sub-interval (e.g. the probe interval (probeBufferInterval) in this case), use ix::util::sizeextent::GetFlatIndices:</p>
<div class="fragment"><div class="line">ix::util::sizeextent <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;      <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probeBufferInterval; <span class="comment">// from above</span></div><div class="line">std::vector&lt;size_t&gt; probeBufferIndices;</div><div class="line">bufferInterval.GetFlatIndices(probeBufferInterval,probeBufferIndices);</div></div><!-- fragment --><p>Now probeBufferIndices vector contains the buffer indices of the locally owned probe points. If one wanted to operate on every local probe point (i.e. every locally-owned point in the region-of-interest), could do the following:</p>
<div class="fragment"><div class="line">ix::util::sizeextent <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;    <span class="comment">// from above</span></div><div class="line">std::vector&lt;size_t&gt; probeBufferIndices; <span class="comment">// from above</span></div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="MetricKernels_8H.html#a091c49fcdc8b19150902448c3c284be2">numPointsBuffer</a> = bufferInterval.NNodes();</div><div class="line">std::vector&lt;double&gt; someBuffer(numPointsBuffer,0);</div><div class="line">std::vector&lt;size_t&gt;::iterator probeIndices = probeBufferIndices.begin();</div><div class="line"><span class="keywordflow">while</span>(probeIndices != probeBufferIndices.end()){                </div><div class="line">  <span class="keywordtype">size_t</span> bufferIndex = *probeIndices++;                         </div><div class="line">  Operate(someBuffer[bufferIndex]);                             </div><div class="line">}                                                                       </div></div><!-- fragment --><h2><a class="anchor" id="mapping"></a>
Mapping coordinates and indices for buffers and intervals</h2>
<h3>Question 4) Given a local buffer index (l0):</h3>
<ul>
<li>(a) what are the point's IJK coordinates wrt the local buffer (B)?</li>
<li>(b) is the point in the halo or in the partition?</li>
<li>(c) what are the point's IJK coordinates wrt the global domain (D)?</li>
<li>(d) is the point within the region of interest (R)?</li>
</ul>
<h3>4a) What are the point's IJK coordinates wrt the local buffer (B)?</h3>
<p>Mapping back-and-forth between l0 and interval-based IJK can be accomplished by the ix::util::sizeextent::Coordinates and ix::util::sizeextent::NodeIndex member functions. These functions are demonstrated by the following code:</p>
<div class="fragment"><div class="line">ix::util::sizeextent <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;          <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent probePartitionInterval;  <span class="comment">// from above</span></div><div class="line">std::vector&lt;size_t&gt; probeBufferIndices;       <span class="comment">// from above</span></div><div class="line"><span class="keywordtype">size_t</span> numLocalProbePoints = probePartitionInterval.NNodes();</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> iProbe = 0;iProbe &lt; numLocalProbePoints;iProbe++){</div><div class="line">   <span class="keywordtype">size_t</span> bufferIndex = probeBufferIndices[iProbe]; <span class="comment">// l0</span></div><div class="line">   <span class="comment">// Get buffer-IJK (bufferInterval-based numbering) for l0</span></div><div class="line">   std::vector&lt;size_t&gt; bufferIJK(bufferInterval.Coordinates(bufferIndex));</div><div class="line">   <span class="comment">// Get l0 back from buffer-IJK</span></div><div class="line">   <span class="keywordtype">size_t</span> resolvedBufferIndex = bufferInterval.NodeIndex(bufferIJK);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In this example, l0 is meant to be the 0-based index into a buffer holding data on each point of the partition (and halos). The IJK coordinates returned by the ix::util::sizeextent::Coordinates member function will have the same numbering scheme as the ix::util::sizeextent itself. That is, if the sizeextent is 1-based then the returned IJK will be 1-based. Similarly, the ix::util::sizeextent::NodeIndex member function will expect an input set of IJK coordinates consistent with the numbering scheme for the sizeextent, and will return a 0-based index that is the buffer index corresponding to the data for the given IJK point.</dd></dl>
<h3>4b) and 4d) Is a given point l0 in the halo, partition or probe/ROI?</h3>
<p>Simple queries about whether intervals contain certain points can be done with the ix::util::sizeextent::Contains member function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> l0;</div><div class="line">ix::util::sizeextent <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;          <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent partitionBufferInterval; <span class="comment">// from above</span></div><div class="line">std::vector&lt;size_t&gt; bufferIJK(bufferInterval.Coordinates(l0));</div><div class="line"><span class="keywordtype">bool</span> pointInPartition = partitionBufferInterval.Contains(bufferIJK);</div><div class="line"><span class="keywordtype">bool</span> pointInHalo      = !pointInPartition;</div><div class="line"><span class="keywordtype">bool</span> pointInProbe     = probeBufferInterval.Contains(bufferIJK);</div></div><!-- fragment --><h3>4c) What are the point's IJK coordinates wrt the global domain (D)?</h3>
<p>The ix::util::sizeextent::RelativeCoordinates and ix::util::sizeextent::TranslateCoordinates member functions are used to map the buffer's IJK coordinates to the global domain (D):</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> l0;</div><div class="line">ix::util::sizeextent <a class="code" href="SATKernels_8H.html#a4caa6f5ca62531b8c31e22919f206d68">bufferInterval</a>;          <span class="comment">// from above</span></div><div class="line">ix::util::sizeextent partitionBufferInterval; <span class="comment">// from above</span></div><div class="line">std::vector&lt;size_t&gt; bufferIJK(bufferInterval.Coordinates(l0));</div><div class="line"><span class="keywordflow">if</span>(partitionBufferInterval.Contains(bufferIJK)){</div><div class="line">  std::vector&lt;size_t&gt; partitionIJK(bufferIJK);<span class="comment">// copy create</span></div><div class="line">  partitionBufferInterval.RelativeCoordinates(partitionIJK);</div><div class="line">  partitionInterval.TranslateCoordinates(partitionIJK);</div><div class="line">  <span class="comment">// partitionIJK is now the IJK coordinates wrt the global</span></div><div class="line">  <span class="comment">// domain (D).</span></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 10 2020 12:24:30 for JustKernels by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
