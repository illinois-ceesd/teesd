<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JustKernels: How To Set Up Testing for an XPACC development using ABATE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xpacc_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JustKernels
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">XPACC Multiphysics simluation application</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('testingproject_guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How To Set Up Testing for an XPACC development using ABATE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="testing_intro"></a>
Introduction</h1>
<p>Testing is part of the XPACC development process. It is very important that we have a consistent, integrated testing in our codes. General guidelines:</p><ul>
<li>We use CMake/CTest/CDash for our automated build and test system (ABATE)</li>
<li>Project unit testing should be centralized/encapsulated in a few constructs</li>
<li>All applications should return 0 to indicate no errors, or passed test, and non-zero otherwise.</li>
<li>Project tests should be integrated through CMake so that the user can use "make test" to run them</li>
</ul>
<h1><a class="anchor" id="testing_constructs_sec"></a>
Testing with IX</h1>
<p>IX offers facilities designed to assist with code and program testing. IX's testing framework supports serial, and parallel tests, platform specific tests, and complex behavior tests. IX's testing facilities come in the form of coding constructs and utility programs. Both are described below. </p>
<h2><a class="anchor" id="ix_testing_code"></a>
IX Testing Constructs</h2>
<p>IX offers the following code constructs for implementing testing in project codes:</p><ul>
<li>ix::util::TestResults</li>
<li>ix::util::TestingObject</li>
</ul>
<p>In general, project-specific testing objects can inherit from the ix::util::TestingObject and implement their own tests as member functions of this derived class. The member methods take an object of type ix::util::TestResults (or one that inherits from this class), and populate it with testing results. The results object can be streamed - and so typically these results can be streamed to the screen, to a file, or string for further processing.</p>
<p>The IX testing code constructs are defined in <code>IX/include/Testing.H</code> and an example of their use can be found in the ix::util::TestObject class. This object implements all the tests for the ix::Util namespace, and is driven by the ix::util::UtilTest function. In other words, the ix::util::UtilTest function implements a command line interface for the ix::util::TestObject, which implements all the existing tests for the ix::Util namespace.</p>
<p>More extensive use of the IX code constructs for testing can be found in the example testing objects for PlasCom2, which are implemented in PlasCom2::TestingObject and PlasCom2::ParallelTestingObject. These testing objects use simple test fixture functions from the PlasCom2::TestFixture namespace and are driven by PlasCom2::Test and PlasCom2::ParallelTest, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>A major advantage of encapsulating all tests in a single object is that external entities need only to instantiate your project-specific testing object to get access to the project's tests. This greatly reduces the complexity of rolling integrated software products out of code from multiple projects.</dd></dl>
<h2><a class="anchor" id="ix_testing_util"></a>
IX Testing Support Utilities</h2>
<p>IX also offers a couple of utilities to support the running of tests. These utilities and their documentation are:</p><ul>
<li><em>runtest</em> (ix::RunTest)</li>
<li><em>testresults</em> (ix::TestResults)</li>
</ul>
<h3>Running complex tests with <em>runtest</em>.</h3>
<p>The <em>runtest</em> utility is designed to be called from the project's CMakeLists.txt cmake configuration file. Its purpose is to run scripted tests where the complexity or platform-dependent nature of the test being run precludes its being run as a simple test. The <em>runtest</em> utility can run a single named executable, a list of test from file, or resolve platform-specific tests.</p>
<p>Examples of how to use the <em>runtest</em> utility can be found in <code>PlasCom2/Testing/CMakeLists.txt</code>, where it is used to run the parallel tests (which must use platform-specific parallel job spawning mechanisms), and other platform-specific, or complex behavior tests.</p>
<h3>Checking test results with <em>testresults</em>.</h3>
<p>The <em>testresults</em> utility is designed to extract a particular test result from a test results file with one test result per line. If the test's results are such that it has passed, then <em>testresults</em> returns with a zero exit code, and exits with a non-zero error code otherwise.</p>
<p>Examples of how to use the <em>testresults</em> utility can be found in <code>PlasCom2/Testing/CMakeLists.txt</code>, where it is used to extract the results of all the tests.</p>
<h2><a class="anchor" id="putting_it_together"></a>
Putting it all together</h2>
<p>All together, the IX testing facilities provide an end-to-end framework for running, collecting, and reporting your project's tests and results to CMake in such a way that CMake's integrated testing facilty, CTest, can be leveraged to integrate the tests into the project's build system, automate the tests, and report the test results to a <em>testing</em> dashboard. The testing dashboard is a web-based facility which collects and reports test results the test histories. XPACC uses CDash for its testing dashboard.</p>
<p>The birds-eye view of the process for using IX's testing facilities with CMake/CTest goes like this:</p><ol type="1">
<li>Create a project-native testing object (PNTO) by inheriting from ix::util::TestingObject.</li>
<li>Implement unit tests as member functions of the PNTO</li>
<li>Write a driver (or a set of drivers) that instantiates your testing object(s), and drives them to produce a ix::util::TestResults object with the restults from the testing.</li>
<li>INCLUDE(CTEST) in your CMakeLists.txt file.</li>
<li>Invoke the test driver(s) with CMake's ADD_TEST() construct and store the results in a composite testing results file. If necessary use <em>runtest</em> to invoke the actual test(s).</li>
<li>If necessary, use <em>testresults</em> to extract the results of the tests from the composite testing results file and exit with a 0 return code for tests that pass, and a non-zero otherwise. This step is also accomplished with CMake's ADD_TEST().</li>
<li>Configure your project (i.e. run cmake), and then run the integrated tests with "make test".</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The reason it may or may not be necessary to use <em>runtest</em> and <em>testresults</em> in steps (5) and (6) is that your tests may be directly invoked by CMake's ADD_TEST <b>if</b> the test is a standalone executable that returns 0 if it succeeds, and non-zero otherwise.</dd></dl>
<h1><a class="anchor" id="ixpt_testing"></a>
Testing in the XPACC Project Template</h1>
<p>Direct examples of using IX Testing for several different kinds of tests are provided in the XPACC Project Template. The following sections summarize the main gist of each of these examples.</p>
<h2><a class="anchor" id="ixpt_serial_tests"></a>
Serial Test Examples</h2>
<p>The XPACC Project Template has both a standalone serial program example, and several serial unit tests. The unit testing is described below, and discussion of the standalone test is deferred to a later section.</p>
<p>For the serial unit tests, the PNTO is called PlasCom2::TestingObject. This object inherits from ix::util::TestingObject as described in Step (1) above. The unit tests are in the PlasCom2::TestingObject's member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p><ul>
<li>PlasCom2::TestingObject::Test__ExampleFunction tests PlasCom2::ExampleFunction</li>
<li>PlasCom2::TestingObject::Test__TrapezoidQuadrature tests PlasCom2::TrapezoidQuadrature</li>
<li>PlasCom2::TestingObject::Test__MidPointQuadrature tests PlasCom2::MidPointQuadrature</li>
</ul>
<p>The <em>plascom2_test</em> command-line driver executable, implemented by the PlasCom2::Test function drives the PlasCom2::TestingObject by instantiating it, and calling the PlasCom2::TestingObject::RunTest (if an explicit test name or list was given) or the PlasCom2::TestingObject::Process method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) is done with the following line from <code>PlasCom2/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunPlasCom2Tests ${EXECUTABLE_OUTPUT_PATH}/plascom2_test -o plascom2_testresults.txt) </p>
</blockquote>
<p>This runs all of the PlasCom2 tests implemented by the PlasCom2::TestingObject, and stores the results in the file <code>plascom2_testresults.txt</code>.</p>
<p>For Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>plascom2_testresults.txt</code> with the following lines from <code>PlasCom2/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleProgram:Works plascom2_testresults.txt)<br />
ADD_TEST(ExampleFunction:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleFunction:Works plascom2_testresults.txt)<br />
ADD_TEST(TrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Runs plascom2_testresults.txt)<br />
ADD_TEST(TrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Accurate plascom2_testresults.txt)<br />
ADD_TEST(TrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Order2 plascom2_testresults.txt)<br />
ADD_TEST(MidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Runs plascom2_testresults.txt)<br />
ADD_TEST(MidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Accurate plascom2_testresults.txt)<br />
ADD_TEST(MidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Order2 plascom2_testresults.txt)<br />
</p>
</blockquote>
<p>In Step (7), users configure PlasCom2 and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="ixpt_parallel_tests"></a>
Parallel Test Examples</h2>
<p>The XPACC Project Template has both a standalone parallel application, <em>pepi</em>, and parallel unit tests. The <em>pepi</em> program computes <img class="formulaInl" alt="$\pi$" src="form_13.png"/> in parallel by doing parallel quadrature, and the unit tests test the parallel quadrature facility. Both will be discussed in this section.</p>
<p>In this test, the PNTO is called PlasCom2::ParallelTestingObject. This object inherits from ix::util::TestingObject as described in Step (1) above. The unit tests are in the PlasCom2::ParallelTestingObject's member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p><ul>
<li>PlasCom2::ParallelTestingObject::Test__ParallelTrapezoidQuadrature tests PlasCom2::TrapezoidQuadrature in parallel</li>
<li>PlasCom2::ParallelTestingObject::Test__ParallelMidPointQuadrature tests PlasCom2::MidPointQuadrature in parallel</li>
</ul>
<p>The <em>plascom2_parallel_test</em> command-line driver executable, implemented by the PlasCom2::ParallelTest function drives the PlasCom2::ParallelTestingObject by instantiating it, and calling the PlasCom2::ParallelTestingObject::RunTest (if an explicit test name or list was given) or the PlasCom2::ParallelTestingObject::Process method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) for this example is more complicated than that of the serial case. Since this is a parallel test, it must be spawned in parallel using something like <em>mpiexec</em> or <em>mpirun</em>. The parallel application spawning mechanism is platform-dependent, and even may need to be done through a batch queueing system.</p>
<p>Due to the platform-specific nature of executing parallel applications, Step (5) must be accomplished using the <em>runtest</em> utility. This is done in the following line from <code>PlasCom2/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunParallelPlatformTests ${EXECUTABLE_OUTPUT_PATH}/runtest -p ${PROJECT_SOURCE_DIR}/share/Platforms/parallel_platforms -o plascom2_testresults.txt) </p>
</blockquote>
<p>This line gives the <code>PlasCom2/share/Platforms/parallel_platforms</code> file as the <em>platform</em> argument to <em>runtest</em>. The parallel_platforms file is line-based and has the following format on each line: </p><blockquote class="doxtable">
<p>&lt;hostname&gt; &lt;path to platform-specific test list&gt; </p>
</blockquote>
<p>If not given on the command line, the <em>runtest</em> utility will determine the hostname and resolve the list of tests from this file. The platform-specific test list should list as many parallel testing scripts as one needs to do on the given platform. For example, see <code>PlasCom2/share/Platforms/parallel_platforms</code>, and <code>PlasCom2/share/Platforms/xpacc_cluster_parallel.list</code>. You will see that the list includes two scripts that invoke the parallel tests:</p><ol type="1">
<li>xpacc_cluster_parallel_test1.csh (runs the parallel unit test driver)</li>
<li>xpacc_cluster_parallel_test2.csh (runs <em>pepi</em>)</li>
</ol>
<p>On XPACC's cluster (xpacc_cluster), these tests must be conducted through the batch system. These testing scripts submit the tests to the batch system and report the results. These results are then fed into the <code>plascom2_testsresults.txt</code> file.</p>
<p>Essentially, these scripts submit the jobs to the cluster's queue, and then wait on the results before returning to the calling utility, <em>runtest</em>. For further details on how they do this, see <code>PlasCom2/share/Platforms/xpacc_cluster_parallel_test1.csh</code> and <code>PlasCom2/share/Platforms/xpacc_cluster_parallel_test2.csh</code>.</p>
<p>Once the <em>runtest</em> utility has returned, then the <code>plascom2_testresults.txt</code> file has been updated with the results from the parallel tests, and, just like for the serial test Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>plascom2_testresults.txt</code> with the following lines from <code>PlasCom2/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ParallelExample:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Runs plascom2_testresults.txt)<br />
ADD_TEST(ParallelExample:Works ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Works plascom2_testresults.txt)<br />
ADD_TEST(ParallelTrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Runs plascom2_testresults.txt)<br />
ADD_TEST(ParallelTrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Accurate plascom2_testresults.txt)<br />
ADD_TEST(ParallelTrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Order2 plascom2_testresults.txt)<br />
ADD_TEST(ParallelTrapezoidQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:WeakScaling plascom2_testresults.txt)<br />
ADD_TEST(ParallelTrapezoidQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:StrongScaling plascom2_testresults.txt)<br />
ADD_TEST(ParallelMidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Runs plascom2_testresults.txt)<br />
ADD_TEST(ParallelMidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Accurate plascom2_testresults.txt)<br />
ADD_TEST(ParallelMidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Order2 plascom2_testresults.txt)<br />
ADD_TEST(ParallelMidPointQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:WeakScaling plascom2_testresults.txt)<br />
ADD_TEST(ParallelMidPointQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:StrongScaling plascom2_testresults.txt)<br />
</p>
</blockquote>
<p>In Step (7), users configure PlasCom2 and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="direct_tests"></a>
Direct Test Example</h2>
<p>The XPACC Project Template has one serial example program called <em>sep</em>. The <em>sep</em> program simply copies a file. It is a useful example because it can be directly invoked by CTest since <em>sep</em> returns 0 if it succeeds and 1 if not (e.g. the input file did not exist or something).</p>
<p>The following line from the <code>PlasCom2/CMakeLists.txt</code> file invokes <em>sep</em> and evaluates whether it succeeded or failed (based solely on its return code):</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Runs ${EXECUTABLE_OUTPUT_PATH}/sep CMakeCache.txt) </p>
</blockquote>
<dl class="section note"><dt>Note</dt><dd>There is no output file, just a name for the test, and then the command it should run.</dd></dl>
<p>In order to evaluate whether <em>sep</em> actually did what it was told to do, we need a more complicated facility. In fact, this is done with <em>runtest</em> just like above. The following line from <code>PlasCom2/CMakeLists.txt</code> runs a (number of) script(s) from a list. One of these scripts, namely <code>PlasCom2/share/Testing/test_scripts/serial_tests.csh</code>, actually runs  and checks to make sure it copies a file correctly:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunTests ${EXECUTABLE_OUTPUT_PATH}/runtest -l ${PROJECT_SOURCE_DIR}/share/Testing/test_scripts/tests.list -o plascom2_testresults.txt) </p>
</blockquote>
<h2><a class="anchor" id="direct_use"></a>
Reusing the Examples</h2>
<p>It is highly recommended to simply reuse the testing examples provided in the XPACC Project Template when creating your own tests that use this framework.</p>
<p>To reuse the example testing objects, the developer could just remove the existing test functions in the serial testing object PlasCom2::TestingObject and the parallel testing object, PlasCom2::ParallelTestingObject and then implement her own unit tests as member functions of those objects.</p>
<p>The corresponding constructs from the <code>CMakeLists.txt</code> file would need to be removed/added as well - and also the scripts invoking the tests, if necessary. The rest of the framework, including the test object drivers would still be valid and should continue to work without modification.</p>
<p>In order to create stand alone tests that utilize scripts users can copy the scripts located in testing/share/Testing/test_scripts and edit them for their needs. Additionally, they will need to follow the examples shown in testing/CMakeLists.txt for calling the standalone tests and add a call for their test. If users are creating a regression test or a "gold standard" test in which they wish to compare saved data to newly generated data a script and example command have been created to help. More information on this regression script is below.</p>
<h2><a class="anchor" id="gold_standard"></a>
Creating a "gold standard" test</h2>
<p>A script is provided to help users in creating a "gold standard" test. The idea behind a "gold standard" test is to have saved output from a previous run of the software, where the solution data or output is known to be accurate. The test will then run the newly compiled version of the software and compare the generated output against the saved data. Located in <b>/testing/share/Testing/test_scripts</b> is a script titled regression.csh. This script is set up to run a "gold standard" test after a few edits from the user. The places in the file that require editing are marked in the script and are explained below.</p>
<p>1) InputDir=_____ This entry should have the name of the input data directory, which should be created by the user and placed in testing/share/Testing/test_data. This directory should house all the necessary input data for running the user's executable. The regression script will copy this directory, navigate into it, and then execute the given command.</p>
<p>2) Outputs=_____ This entry should contain the names of the generated output files that the user wishes to compare with saved data.</p>
<p>3) OutputsCheck=_____ This entry should contain the names of the saved output data files to compare the new output files against. Note that the files are compared using the diff command. Also, the files in Outputs must have a one to one corresponence with the files in OutputsCheck.</p>
<p>4) TestName=_____ This entry should contain the name the user wishes to use for the test.</p>
<p>5) The command for running the user's executable should be entered at the appropriate place in the script (the loaction is indicated with a comment). The user can also add any other features to the script that may be specific to a test.</p>
<p>In order to run the test and check the results two lines need to be uncommented and one of them edited in testing/CMakeLists.txt. These two lines are present in the testing section and are indicated by RegressionTest as the test name. The first of these must be uncommented. This line calls the runtest executable which in turn calls the regression.csh script. The second instance with RegresionTest calls the testresult executable and verifies the output of the regression.csh script. This second line must be edited to have the name of the user's test used in 4) above. These names must match exactly or the test will indicate failure even if that is not the case. The location to place the test name is indicated in the file. The regression test should then be ready to run with the other tests.</p>
<p>Note that the regression.csh script utilizes an executable called diffdatafiles which is part of IX. This executable works like the Unix diff command but will also compare numbers within a given tolerance. Additionally it can be directed to ignore strings and only compare numbers. Using this command users can compare their numerical output to ensure that the answers are within a certain tolerance and ignore other aspects of a data file that might be unimportant like a time and date stamp. The default written into the script is to compare all output files using only the numbers and comparing within a tolerance of 1.0e-10. Therefore, diffdatafiles will read in each string from the two data files one at a time. If the strings are in fact numbers it will ensure that the two numbers from each file are within 1.0e-10 of one another (strings will not be compared). The usage for the diffdatafiles command is shown below so that users may change its arguments and runtime behavior if desired. </p><pre class="fragment">    diffdatafiles [-hnb] [-v [level] -o &lt;filename&gt; -t [tolerance] ] &lt;file1&gt; &lt;file2&gt; 

    -h,--help
            Print out long version of help and exit.

    -v,--verblevel [level]
            Set the verbosity level. (default = 1)

    -o,--output &lt;filename&gt;
            Set the output file to &lt;filename&gt;. (default = stdout)

    -t,--tolerance [tolerance]
            Set the numerical tolerance for comparing numbers to &lt;tolerance&gt;.
            (The default for the tolerance is 1.0e-12.)
            (The default behavior without -t is to compare numbers as strings.)
            (This flag will automatically force the -b flag to be used.)

    -n,--numbers
            Only compare the numbers in the two files.
            (This flag will automatically force the -t flag to be used.)

    -b,--blank
            Ignore blank space between words (or numbers).

    &lt;file1&gt;
            First file to read in for comparison against file2.

    &lt;file2&gt;
            Second file to read in for comparison against file1.
</pre><h1><a class="anchor" id="autotesting_sec"></a>
Automated Testing</h1>
<p>The XPACC Project Template has a couple of utilities designed to assist in understanding and setting up automated testing through <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest</a>. A sort of "quickstart" set of steps for setting up automated testing is as follows:</p><ol type="1">
<li>Log in to XPACC's <a href="http://xpacc-cluster-hn.csl.illinois.edu/CDash">CDash</a> instance and create a new project for your project (if it does not already exist).</li>
<li>Make a directory from which to run your automated builds and tests (e.g. ~/AutomatedTesting).</li>
<li>Copy <code>PlasCom2/share/Testing/test_scripts/ctest/{automated_test_script.cmake</code>,run_automated_tests,projects,modules,documentation} into your testing directory.</li>
<li>Edit the projects file to remove the examples and add the projects that you want to test.</li>
<li>Modify the environment module file in modules directory for your projects to reflect the desired build environment.</li>
<li>Modify the documentation file for your project if you want automatic documentation builds</li>
<li>Edit the run_automated_tests script with your customizations.</li>
<li>Test the setup by executing: <blockquote class="doxtable">
<p><code></code>./run_automated_tests <code></code>./projects Experimental <code>~/AutomatedTesting</code> </p>
</blockquote>
</li>
<li>If everything works OK, then add a cron job to invoke <em>run_automated_tests</em> at your desired intervals and modes.</li>
</ol>
<p>For Step(1), log into <a href="http://xpacc-cluster-hn.csl.illinois.edu/CDash">CDash</a> and follow the steps to create a new project. Add yourself as an author, and anyone else that should know about the status of the automated builds/tests.</p>
<p>Steps(2) and (3) are obvious.</p>
<p>In Step(4), it should be noted that the projects file is processed line-by-line. Each line should indicate the parameters for a single build and test. The expected format for each functional line of projects file is as follows:</p>
<blockquote class="doxtable">
<p>&lt;Project Name&gt;|&lt;Branch Name&gt;|&lt;Branch Path&gt;|&lt;Repository Type&gt;|&lt;Documentation Target&gt; </p>
</blockquote>
<p>Based on the line from the projects file, the testing utilities will automatically try to check out the following branch from either GIT or SVN with the following command:</p>
<p>svn: </p><blockquote class="doxtable">
<p><code>svn</code> <code>co</code> <code>&lt;Branch</code> Path&gt; <code>&lt;Project</code> Name&gt;_&lt;Branch Name&gt; </p>
</blockquote>
<p>git: </p><blockquote class="doxtable">
<p><code>git</code> <code>clone</code> <code>&lt;Branch</code> Path&gt; <code>&lt;Project</code> Name&gt;_&lt;Branch Name&gt; </p>
</blockquote>
<p>If the &lt;Project Name&gt;_&lt;Branch Name&gt; directory already exists, then CTest will simply update from SVN if there are changes in the repository. On fresh check-outs or updates, CTest will (re)configure and (re)build the project and run the tests.</p>
<p>In Step(5), the script automatically loads (and subsequently unloads) an environment module file with the project name (if it exists). The module files should setup up the required build environment and reduce the need for hand editing of the run_automated_tests script.</p>
<p>In Step(6), the testing framework will build documentation for a project if it is enabled through the CMake option BUILD_DOCUMENTATION. The documentation can be installed in either a specified directory to which the user has access or uploaded to a git branch. The latter effectively publishes our documentation to the internet, complete with source code (depending on the Doxygen options enabled). The user should add a file with the name of the project in the documentation directory. The expected format of each functional line is as follows:</p>
<blockquote class="doxtable">
<p>&lt;destination&gt;|&lt;path&gt;|&lt;doc_src&gt; </p>
</blockquote>
<p>&lt;destination&gt; is either local or git &lt;path&gt; is either a local path accessible to the user, or a git branch name (typically gh-pages) &lt;doc_src&gt; is the directory for the documentation to be copied to.</p>
<p>The presence of a project specific file will enable building of the documentation specified by the build target in the projects file. Note that the documentation build can be disabled if the user specifies "none" for the documentation target.</p>
<p>To add documentation to github, the user should create a branch named gh-pages containing the contents of the html directory created by doxygen.</p>
<p>In Step(7), pay particular attention to the settings of the shell, and to the two optional environment settings, <code>CMAKE_PREFIX_PATH</code> and <code>PROJECT_CONFIGURE_OPTIONS</code>. These options are passed to CMake when CTest configures your project(s) for automated build and testing. Ideally, any environment specific options should be handled by the module files to keep the build environment clean for subsequent projects.</p>
<p>For Step(8), make sure to replace "~/AutomatedTesting" with the directory that you created in Step(2). The usage for the <em>run_automated_tests</em> utility is as follows:</p>
<blockquote class="doxtable">
<p>run_automated_tests &lt;projects file&gt; &lt;mode&gt; &lt;running directory&gt; </p>
</blockquote>
<p>Valid default modes are <em>Experimental</em>, <em>Nightly</em>, and <em>Continuous</em>. The only real difference between Experimental and Nightly is how they are denoted in CDash. Experimental builds can happen at any time, whereas nightly tests are expected to be, well... nightly. Continuous builds are useful for things such as Test Driven Development. Continuous builds do not require cron jobs - but automatically update and build your project according to an interval that you can specify, say every 2 minutes or every 10 minutes for example.</p>
<p>In Step(9), your cron job will (presumably) invoke the nightly build/tests. Assuming you want to to run nightly build and test every night at midnight, say, then your crontab would be:</p>
<blockquote class="doxtable">
<p>00 00 * * * /home/my/AutomatedTesting/run_automated_tests /home/my/AutomatedTesting/projects Nightly /home/my/AutomatedTesting </p>
</blockquote>
<p>In general, the format for the crontab is: </p><blockquote class="doxtable">
<p>MM HH DD NN W Command </p>
</blockquote>
<p>Where MM is the two digit minute, HH the two digit hour (in 24 hour format), DD is date of the month, NN is the month, and W is the day of the week (0-6). "Command" is the command to be executed.</p>
<p>Once you have all of this working, the building and testing can be more easily customized. The <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest Manual</a> is useful in learning about the ways this process can be customized further. Builds and tests can also be customized or made more specific by editing/tweaking the <em>run_automated_tests</em> script and cron job(s). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 10 2020 12:24:30 for JustKernels by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
