.TH "testing_reference" 3 "Fri Apr 10 2020" "Version 1.0" "JustKernels" \" -*- nroff -*-
.ad l
.nh
.SH NAME
testing_reference \- Testing Reference 
The intent of this page is to provide some useful information about the PlasCom2 testing framework\&.
.PP
.IP "\(bu" 2
\fBRunning Tests\fP
.IP "\(bu" 2
\fBAdding Tests\fP
.IP "\(bu" 2
\fBAdding Suites\fP
.IP "\(bu" 2
\fBAnatomy of PlasCom2 Testing\fP
.PP
.SH "Running Tests"
.PP
The PlasCom2 testing can be run after configuration and building with:
.PP
.RS 4
make test 
.RE
.PP
.PP
At this point CMake/CTest will take over and stage-in all of the testing data in Testing/Data to the build/test area and execute all of the enabled tests\&. Typically, the default tests will take around 5-10 minutes on a modern laptop to run, and will use 4 MPI ranks\&. Upon completion, the results of all the tests will be summarized\&. A summary of test failures is presented at the end of the tests summary\&.
.PP
\fBNote:\fP
.RS 4
Any failing tests with \fBFAILS\fP in the test name is a known, non-critical failure\&. Any failing test \fIwithout\fP the FAILS keyword could indicate that your PlasCom2 build is broken in some way\&.
.RE
.PP
There are several places where the actual output of the tests and the testing framework can be reviewed:
.PP
.IP "\(bu" 2
<build>/Testing/parallel_test_output\&.txt - is a log of the output of the actual test functions that are executed during the testing
.IP "\(bu" 2
<build>/Testing/Temporary/LastTest\&.log - is a log of the output of testing framework and* the output of the testing functions\&.
.PP
.PP
Users may also directly run the PlasCom2 test drivers to execute only a suite of tests at-a-time\&. Any data required by the suite should be staged into the current directory when attempting to directly run the PlasCom2 test drivers\&. In general individual suites can be run as follows:
.PP
.RS 4
cd <build>/Testing
.br
\&.\&./bin/plascom2_test -n <serial_suite_name> 
.RE
.PP
-or- 
.PP
.RS 4
mpiexec -n 4 \&.\&./bin/plascom2_parallel_test -n <parallel_suite_name> 
.RE
.PP
.PP
\fBNote:\fP
.RS 4
Running single individual tests is not currently supported, but is coming soon\&.
.RE
.PP
.SH "Adding Tests"
.PP
This section is about adding tests to an existing suite of tests\&. Adding tests to an existing suite is the most common way to add a test\&. Adding tests to existing suites that use a \fIsuite driver\fP is trivial\&. This section will focus on adding legacy tests for existing suites that do not use a suite driver\&.
.PP
The general procedure is as follows:
.PP
.IP "\(bu" 2
\fBAdd or edit a test function\fP
.IP "\(bu" 2
\fBAdd a test function prototype\fP
.IP "\(bu" 2
\fBAdd appropriate calls to the test functions to the PlasCom2 testing object\fP
.PP
.SS "Add a Test Function"
Test functions for testing suites without suite drivers are directly called by the PC2 testing framework\&. Test functions are defined in Testing/src/Test<XXX>\&.C\&. Test functions (and suite drivers) must all follow the standard prototypes\&.
.PP
Serial prototype: 
.PP
.RS 4
void Test<MyName>(ix::test::results &); 
.RE
.PP
.PP
Parallel prototype: 
.PP
.RS 4
void Test<MyName>(ix::test::results &,ix::comm::CommunicatorObject &); 
.RE
.PP
.PP
Examples of testing functions can be found in any file Testing/src/Test<XXX>\&.C\&. Example serial and parallel suite drivers can be found in Testing/src/TestExample\&.C\&.
.PP
To add your own test function, open or create a file Testing/src/Test<XXX>\&.C and add a new function with the required function prototype\&. Alternatively, edit an existing test function to add your test\&. Inside your test function, for every test you want to add, add a call to ix::test::results::UpdateResult to indicate whether your test passes or fails\&. For example:
.PP
.PP
.nf
void TestMyTest(ix::test::results &testResults)
{
   testResults\&.UpdateResult("MySuite:MyTest:Ran",true);
}
.fi
.PP
.PP
In this example, the test function is named \fITestMyTest\fP, the name of the suite is \fIMySuite\fP, and the name of the test is \fIMyTest:Ran\fP\&. It is hardcoded to \fItrue\fP for a function pass, and simply indicates that the test function has been executed\&.
.PP
For new test functions (or new suite drivers) that are not called from an existing suite driver, the next step for getting the new function called by the testing framework is to add the test function's prototype to Testing/include/ExternalTestingFunctions\&.H\&. This step is explained in \fBAdd a Testing Function Prototype\fP\&.
.PP
\fBNote:\fP
.RS 4
Test functions for suites with a suite driver can have arbitrary function prototypes and do not require any additional steps beyond writing the function and calling it from the suite driver\&.
.RE
.PP
.SS "Add a Testing Function Prototype"
Adding a function prototype for each function to be called by the framework is required to provide the PlasCom2 testing object knowledge about the function it must call\&. This step is easily done by editing Testing/include/ExternalTestingFunctions\&.H and adding a function prototype for your testing function(s)\&.
.PP
For the example testing function provided in the \fBAdd a Test Function\fP section, one would edit Testing/include/ExternalTestingFunctions\&.H and add the following line(s):
.PP
.PP
.nf
// new test function by [myname]
void TestMyTest(ix::test::results &);
.fi
.PP
.PP
The next step is adding the appropriate calls to the PlasCom2 Testing Object, which is explained in \fBAdd new Testing Function to Testing Object\fP\&.
.SS "Add new Testing Function to Testing Object"
The PlasCom2 Testing Object is driven by the PlasCom2 test drivers when tests are executed\&. In order for your new test function(s) or suite driver(s) to be called by the testing framework, calls to those must be added to the PlasCom2 Testing Object by editing Testing/include/PlasCom2Test\&.H\&.
.PP
Typically, 3 things must be added to the PlasCom2 Testing Object for each new test function or suite driver\&.
.PP
.IP "\(bu" 2
\fBFunction Wrapper\fP
.IP "\(bu" 2
\fBCall in Process method\fP
.IP "\(bu" 2
\fBCall by Name\fP
.PP
.SS "Function Wrapper"
Function wrappers are added to the PlasCom2 Testing Object by editing Testing/include/PlasCom2Test\&.H\&.
.PP
Function wrappers with a standard form are used to access testing functions (and suite drivers) in the PlasCom2 Testing Object\&. We follow a specific form to make automation easier\&. There are many existing function wrappers that can be used as examples in PlasCom2Test\&.H\&.
.PP
Following the example from previous sections, the test function wrapper that would be added here is:
.PP
.PP
.nf
void Test__MySuite__MyTest(ix::test::results &result)
{ TestMyTest(result); };
.fi
.PP
.PP
For a parallel test, the wrapper looks as follows:
.PP
.PP
.nf
void Test__MySuite__MyParallelTest(ix::test::results &result)
{ TestMyParallelTest(result,_communicator); };
.fi
.PP
.PP
Once the required wrappers are implemented, the PlasCom2 Testing Object will access the test function(s) (or suite driver) through calls to the wrapper\&.
.PP
Calls to the wrapper(s) must be added in two places, in the \fIProcess\fP method and in the \fIRunTest\fP method\&. The Process method executes \fIall\fP of the tests while the RunTest method executes testing suites by name\&.
.SS "Call in Process method"
Add a call to the wrapper in the plascom2::TestingObject::Process method, or plascom2::ParallelTestingObject::Process as is appropriate for a serial or parallel test, respectively\&.
.SS "Call by Name"
Add a call to the wrapper in the plascom2::TestingObject::RunTest method in the appropriate suite-specific construct (or plascom2::ParallelTestingObject::RunTest for a parallel test)\&.
.SH "Adding Suites"
.PP
The high level steps for adding a new testing suite are:
.PP
.IP "\(bu" 2
\fBAdding a new testing suite\fP
.IP "\(bu" 2
\fBAdd new suite to suite lists\fP
.PP
.SS "Adding a new testing suite"
A new suite is required when developers add tests that do not fit into any existing suite\&. Creating a new test suite is simply done by specifying an unknown suite name in a call to ix::test::results::UpdateResult\&. For example:
.PP
.PP
.nf
void TestMyTest(ix::test::results &testResults)
{
  \&.\&.\&.
  testResults\&.UpdateResult("MyNewSuite:MyTestName",true);
  \&.\&.\&.
}
.fi
.PP
.PP
It is highly recommended when adding new suites to use a suite driver\&. Use of the suite driver greatly reduces the complexity and steps for adding new tests in the suite\&. Example suite drivers can be found in Testing/src/TestExample\&.C as ExamplesSerialTestDriver, and ExamplesParallelTestDriver\&.
.PP
\fBNote:\fP
.RS 4
For brand new suites, developers can copy Testing/src/TestExample\&.C to a test file name of their choice and rename the functions appropriately\&. Then add the new suite driver to the framework similarly to the steps outlined in previous sections for new testing functions\&.
.RE
.PP
.SS "Add new suite to suite lists"
This step makes the testing framework aware of your new suite\&. If your new suite has serial tests, add a line for the suite containing only the name of the suite to Testing/Scripts/serialUnitSuites\&.txt\&. If your new suite has parallel tests, add the suite name to Testing/Scripts/parallelUnitSuites\&.txt\&.
.PP
After adding suites, PlasCom2 needs to be reconfigured to make the testing framework aware of the new suite\&.
.PP
\fBNote:\fP
.RS 4
At configuration (cmake) time, a verbose listing of tests and suites can be generated if one uses the option _-DSHOWTESTS=1_\&. This can be a convenient way to indicate whether your suite and tests have been properly added\&.
.RE
.PP
.SH "Additional Topics"
.PP
This section will talk about FAIL keyword, suite drivers, optional test exclusions, adding platforms, running tests, and debugging tests\&.
.SH "Anatomy of PlasCom2 Testing"
.PP
The PlasCom2 testing framework consists of several parts:
.IP "\(bu" 2
\fBCode Parser\fP
.IP "\(bu" 2
\fBPlasCom2 Testing Object\fP
.IP "\(bu" 2
\fBTest Drivers\fP
.IP "\(bu" 2
\fBTesting Functions\fP
.IP "\(bu" 2
\fBTest Suites\fP
.IP "\(bu" 2
\fBTests\fP
.IP "\(bu" 2
\fBPlatform Drivers\fP
.IP "\(bu" 2
\fBCMake/CTest\fP
.PP
.SS "Code Parser"
The Code Parser automatically detects tests added by user/developers\&. User/developers do not often need to fiddle with the Code Parser\&. The Code Parser looks through all files matching the 'Test*' pattern in the Testing/src subdirectory and finds any calls to 'UpdateResult' and extracts the 'SuiteName' and 'TestName' from that call\&. The parse happens at PlasCom2 config-time (i\&.e\&. CMake)\&. The lists of testing suites and tests is accumulated, pruned, and eventually provided to CMake/CTest at PlasCom2 configuration time and test time\&. One can find the parse/prune functionality in Testing/CMakeLists\&.txt\&.
.SS "PlasCom2 Testing Object"
The PlasCom2 Testing Object is an object that encapsulates all the unit and integrated tests implemented for PlasCom2\&. It is implemented in Testing/include/PlasCom2Test\&.H\&. Each 'Testing Function' is called as in a member method of the PlasCom2 Testing Object\&.
.SS "Test Drivers"
The PlasCom2 Test Drivers execute the tests optionally by suite or test name\&. There is a parallel test driver (plascom2_parallel_test) and a serial test driver (plascom2_test)\&. Each of these drivers instantiate a PlasCom2 Testing Object and drive it to run the tests\&.
.SS "Testing Functions"
The Testing Functions are those functions that the PlasCom2 Testing Object calls from its member methods that implement the tests\&. The user writes these Testing Functions\&. Testing Functions must be \fIvoid\fP\&. Each Testing Function needs to be added to the testing prototypes in Testing/include/ExternalTestingFunctions\&.H and a PlasCom2 Testing Object member method added in Testing/include/PlasCom2Test\&.H to call the Testing Function\&.
.SS "Test Suites"
Test Suites are collections of Tests\&. Every Test belongs to a Suite\&. The testing framework executes each Test Suite in-turn when the user invokes 'make test'\&. See \fBAdding Suites\fP for how to add new suites to the testing framework\&.
.SS "Tests"
Tests are defined, from the testing framework's perspective, as a call to 'UpdateResults' method of the ix::test::results object\&. The arguments to UpdateResults indicate the 'SuiteName' and the 'TestName' for the test:
.PP
.RS 4
results\&.UpdateResults('<SuiteName>:<TestName>'); 
.RE
.PP
.PP
.IP "\(bu" 2
The 'TestName' is arbitrary, user-defined
.IP "\(bu" 2
The 'SuiteName' should be an existing suite -OR- see \fBaddsuites\fP
.PP
.PP
The results for every named test will be reported by CTest when the user invokes: 
.PP
.RS 4
make test 
.RE
.PP
.SS "Platform Drivers"
Platform drivers are scripts that help the tests navigate the resource management system (e\&.g\&. batch queue) for each platform\&. Users do not typically need to tinker with these, but mostly they can be found in Testing/Platforms
.SS "CMake/CTest"
CMake/CTest - the PlasCom2 testing framework (currently) uses CMake to help parse and prune the lists of tests to run for any given configuration\&. CTest is used to run the tests and report the results on all platforms\&. 
