The intent of this page is to provide some useful information about the Plas\+Com2 testing framework.


\begin{DoxyItemize}
\item \hyperlink{testing_reference_running}{Running Tests}
\item \hyperlink{testing_reference_addtest}{Adding Tests}
\item \hyperlink{testing_reference_addsuite}{Adding Suites}
\item \hyperlink{testing_reference_anatomy}{Anatomy of Plas\+Com2 Testing}
\end{DoxyItemize}\hypertarget{testing_reference_running}{}\section{Running Tests}\label{testing_reference_running}
The Plas\+Com2 testing can be run after configuration and building with\+:

\begin{quote}
make test \end{quote}


At this point C\+Make/\+C\+Test will take over and stage-\/in all of the testing data in Testing/\+Data to the build/test area and execute all of the enabled tests. Typically, the default tests will take around 5-\/10 minutes on a modern laptop to run, and will use 4 M\+PI ranks. Upon completion, the results of all the tests will be summarized. A summary of test failures is presented at the end of the tests summary.

\begin{DoxyNote}{Note}
Any failing tests with {\bfseries F\+A\+I\+LS} in the test name is a known, non-\/critical failure. Any failing test {\itshape without} the F\+A\+I\+LS keyword could indicate that your Plas\+Com2 build is broken in some way.
\end{DoxyNote}
There are several places where the actual output of the tests and the testing framework can be reviewed\+:


\begin{DoxyItemize}
\item $<$build$>$/\+Testing/parallel\+\_\+test\+\_\+output.txt -\/ is a log of the output of the actual test functions that are executed during the testing
\item $<$build$>$/\+Testing/\+Temporary/\+Last\+Test.log -\/ is a log of the output of testing framework and$\ast$ the output of the testing functions.
\end{DoxyItemize}

Users may also directly run the Plas\+Com2 test drivers to execute only a suite of tests at-\/a-\/time. Any data required by the suite should be staged into the current directory when attempting to directly run the Plas\+Com2 test drivers. In general individual suites can be run as follows\+:

\begin{quote}
cd $<$build$>$/\+Testing~\newline
../bin/plascom2\+\_\+test -\/n $<$serial\+\_\+suite\+\_\+name$>$ \end{quote}
-\/or-\/ \begin{quote}
mpiexec -\/n 4 ../bin/plascom2\+\_\+parallel\+\_\+test -\/n $<$parallel\+\_\+suite\+\_\+name$>$ \end{quote}


\begin{DoxyNote}{Note}
Running single individual tests is not currently supported, but is coming soon.
\end{DoxyNote}
\hypertarget{testing_reference_addtest}{}\section{Adding Tests}\label{testing_reference_addtest}
This section is about adding tests to an existing suite of tests. Adding tests to an existing suite is the most common way to add a test. Adding tests to existing suites that use a {\itshape suite driver} is trivial. This section will focus on adding legacy tests for existing suites that do not use a suite driver.

The general procedure is as follows\+:


\begin{DoxyItemize}
\item \hyperlink{testing_reference_addfunc}{Add or edit a test function}
\item \hyperlink{testing_reference_addproto}{Add a test function prototype}
\item \hyperlink{testing_reference_addcall}{Add appropriate calls to the test functions to the Plas\+Com2 testing object}
\end{DoxyItemize}\hypertarget{testing_reference_addfunc}{}\subsection{Add a Test Function}\label{testing_reference_addfunc}
Test functions for testing suites without suite drivers are directly called by the P\+C2 testing framework. Test functions are defined in Testing/src/\+Test$<$\+X\+X\+X$>$.C. Test functions (and suite drivers) must all follow the standard prototypes.

Serial prototype\+: \begin{quote}
void Test$<$\+My\+Name$>$(ix\+::test\+::results \&); \end{quote}


Parallel prototype\+: \begin{quote}
void Test$<$\+My\+Name$>$(ix\+::test\+::results \&,ix\+::comm\+::\+Communicator\+Object \&); \end{quote}


Examples of testing functions can be found in any file Testing/src/\+Test$<$\+X\+X\+X$>$.C. Example serial and parallel suite drivers can be found in Testing/src/\+Test\+Example.\+C.

To add your own test function, open or create a file Testing/src/\+Test$<$\+X\+X\+X$>$.C and add a new function with the required function prototype. Alternatively, edit an existing test function to add your test. Inside your test function, for every test you want to add, add a call to ix\+::test\+::results\+::\+Update\+Result to indicate whether your test passes or fails. For example\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} TestMyTest(ix::test::results &testResults)
\{
   testResults.UpdateResult(\textcolor{stringliteral}{"MySuite:MyTest:Ran"},\textcolor{keyword}{true});
\}
\end{DoxyCode}


In this example, the test function is named {\itshape Test\+My\+Test}, the name of the suite is {\itshape My\+Suite}, and the name of the test is {\itshape My\+Test\+:Ran}. It is hardcoded to {\itshape true} for a function pass, and simply indicates that the test function has been executed.

For new test functions (or new suite drivers) that are not called from an existing suite driver, the next step for getting the new function called by the testing framework is to add the test function\textquotesingle{}s prototype to Testing/include/\+External\+Testing\+Functions.\+H. This step is explained in \hyperlink{testing_reference_addproto}{Add a Testing Function Prototype}.

\begin{DoxyNote}{Note}
Test functions for suites with a suite driver can have arbitrary function prototypes and do not require any additional steps beyond writing the function and calling it from the suite driver.
\end{DoxyNote}
\hypertarget{testing_reference_addproto}{}\subsection{Add a Testing Function Prototype}\label{testing_reference_addproto}
Adding a function prototype for each function to be called by the framework is required to provide the Plas\+Com2 testing object knowledge about the function it must call. This step is easily done by editing Testing/include/\+External\+Testing\+Functions.\+H and adding a function prototype for your testing function(s).

For the example testing function provided in the \hyperlink{testing_reference_addfunc}{Add a Test Function} section, one would edit Testing/include/\+External\+Testing\+Functions.\+H and add the following line(s)\+:


\begin{DoxyCode}
\textcolor{comment}{// new test function by [myname]}
\textcolor{keywordtype}{void} TestMyTest(ix::test::results &);
\end{DoxyCode}


The next step is adding the appropriate calls to the Plas\+Com2 Testing Object, which is explained in \hyperlink{testing_reference_addcall}{Add new Testing Function to Testing Object}.\hypertarget{testing_reference_addcall}{}\subsection{Add new Testing Function to Testing Object}\label{testing_reference_addcall}
The Plas\+Com2 Testing Object is driven by the Plas\+Com2 test drivers when tests are executed. In order for your new test function(s) or suite driver(s) to be called by the testing framework, calls to those must be added to the Plas\+Com2 Testing Object by editing Testing/include/\+Plas\+Com2\+Test.\+H.

Typically, 3 things must be added to the Plas\+Com2 Testing Object for each new test function or suite driver.


\begin{DoxyItemize}
\item \hyperlink{testing_reference_wrapper}{Function Wrapper}
\item \hyperlink{testing_reference_processcall}{Call in Process method}
\item \hyperlink{testing_reference_callbyname}{Call by Name}
\end{DoxyItemize}\hypertarget{testing_reference_wrapper}{}\subsubsection{Function Wrapper}\label{testing_reference_wrapper}
Function wrappers are added to the Plas\+Com2 Testing Object by editing Testing/include/\+Plas\+Com2\+Test.\+H.

Function wrappers with a standard form are used to access testing functions (and suite drivers) in the Plas\+Com2 Testing Object. We follow a specific form to make automation easier. There are many existing function wrappers that can be used as examples in Plas\+Com2\+Test.\+H.

Following the example from previous sections, the test function wrapper that would be added here is\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} Test\_\_MySuite\_\_MyTest(ix::test::results &result)
\{ TestMyTest(result); \};
\end{DoxyCode}


For a parallel test, the wrapper looks as follows\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} Test\_\_MySuite\_\_MyParallelTest(ix::test::results &result)
\{ TestMyParallelTest(result,\_communicator); \};
\end{DoxyCode}


Once the required wrappers are implemented, the Plas\+Com2 Testing Object will access the test function(s) (or suite driver) through calls to the wrapper.

Calls to the wrapper(s) must be added in two places, in the {\itshape Process} method and in the {\itshape Run\+Test} method. The Process method executes {\itshape all} of the tests while the Run\+Test method executes testing suites by name.\hypertarget{testing_reference_processcall}{}\subsubsection{Call in Process method}\label{testing_reference_processcall}
Add a call to the wrapper in the plascom2\+::\+Testing\+Object\+::\+Process method, or plascom2\+::\+Parallel\+Testing\+Object\+::\+Process as is appropriate for a serial or parallel test, respectively.\hypertarget{testing_reference_callbyname}{}\subsubsection{Call by Name}\label{testing_reference_callbyname}
Add a call to the wrapper in the plascom2\+::\+Testing\+Object\+::\+Run\+Test method in the appropriate suite-\/specific construct (or plascom2\+::\+Parallel\+Testing\+Object\+::\+Run\+Test for a parallel test).\hypertarget{testing_reference_addsuite}{}\section{Adding Suites}\label{testing_reference_addsuite}
The high level steps for adding a new testing suite are\+:


\begin{DoxyItemize}
\item \hyperlink{testing_reference_newsuite}{Adding a new testing suite}
\item \hyperlink{testing_reference_addlist}{Add new suite to suite lists}
\end{DoxyItemize}\hypertarget{testing_reference_newsuite}{}\subsection{Adding a new testing suite}\label{testing_reference_newsuite}
A new suite is required when developers add tests that do not fit into any existing suite. Creating a new test suite is simply done by specifying an unknown suite name in a call to ix\+::test\+::results\+::\+Update\+Result. For example\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} TestMyTest(ix::test::results &testResults)
\{
  ...
  testResults.UpdateResult(\textcolor{stringliteral}{"MyNewSuite:MyTestName"},\textcolor{keyword}{true});
  ...
\}
\end{DoxyCode}


It is highly recommended when adding new suites to use a suite driver. Use of the suite driver greatly reduces the complexity and steps for adding new tests in the suite. Example suite drivers can be found in Testing/src/\+Test\+Example.\+C as Examples\+Serial\+Test\+Driver, and Examples\+Parallel\+Test\+Driver.

\begin{DoxyNote}{Note}
For brand new suites, developers can copy Testing/src/\+Test\+Example.\+C to a test file name of their choice and rename the functions appropriately. Then add the new suite driver to the framework similarly to the steps outlined in previous sections for new testing functions.
\end{DoxyNote}
\hypertarget{testing_reference_addlist}{}\subsection{Add new suite to suite lists}\label{testing_reference_addlist}
This step makes the testing framework aware of your new suite. If your new suite has serial tests, add a line for the suite containing only the name of the suite to Testing/\+Scripts/serial\+Unit\+Suites.\+txt. If your new suite has parallel tests, add the suite name to Testing/\+Scripts/parallel\+Unit\+Suites.\+txt.

After adding suites, Plas\+Com2 needs to be reconfigured to make the testing framework aware of the new suite.

\begin{DoxyNote}{Note}
At configuration (cmake) time, a verbose listing of tests and suites can be generated if one uses the option \+\_\+-\/\+D\+S\+H\+O\+W\+T\+E\+S\+TS=1\+\_\+. This can be a convenient way to indicate whether your suite and tests have been properly added.
\end{DoxyNote}
\hypertarget{testing_reference_additional}{}\section{Additional Topics}\label{testing_reference_additional}
This section will talk about F\+A\+IL keyword, suite drivers, optional test exclusions, adding platforms, running tests, and debugging tests.\hypertarget{testing_reference_anatomy}{}\section{Anatomy of Plas\+Com2 Testing}\label{testing_reference_anatomy}
The Plas\+Com2 testing framework consists of several parts\+:
\begin{DoxyItemize}
\item \hyperlink{testing_reference_parser}{Code Parser}
\item \hyperlink{testing_reference_object}{Plas\+Com2 Testing Object}
\item \hyperlink{testing_reference_drivers}{Test Drivers}
\item \hyperlink{testing_reference_functions}{Testing Functions}
\item \hyperlink{testing_reference_suites}{Test Suites}
\item \hyperlink{testing_reference_tests}{Tests}
\item \hyperlink{testing_reference_platforms}{Platform Drivers}
\item \hyperlink{testing_reference_cmake}{C\+Make/\+C\+Test}
\end{DoxyItemize}\hypertarget{testing_reference_parser}{}\subsection{Code Parser}\label{testing_reference_parser}
The Code Parser automatically detects tests added by user/developers. User/developers do not often need to fiddle with the Code Parser. The Code Parser looks through all files matching the \char`\"{}\+Test$\ast$\char`\"{} pattern in the Testing/src subdirectory and finds any calls to \char`\"{}\+Update\+Result\char`\"{} and extracts the \char`\"{}\+Suite\+Name\char`\"{} and \char`\"{}\+Test\+Name\char`\"{} from that call. The parse happens at Plas\+Com2 config-\/time (i.\+e. C\+Make). The lists of testing suites and tests is accumulated, pruned, and eventually provided to C\+Make/\+C\+Test at Plas\+Com2 configuration time and test time. One can find the parse/prune functionality in Testing/\+C\+Make\+Lists.\+txt.\hypertarget{testing_reference_object}{}\subsection{Plas\+Com2 Testing Object}\label{testing_reference_object}
The Plas\+Com2 Testing Object is an object that encapsulates all the unit and integrated tests implemented for Plas\+Com2. It is implemented in Testing/include/\+Plas\+Com2\+Test.\+H. Each \char`\"{}\+Testing Function\char`\"{} is called as in a member method of the Plas\+Com2 Testing Object.\hypertarget{testing_reference_drivers}{}\subsection{Test Drivers}\label{testing_reference_drivers}
The Plas\+Com2 Test Drivers execute the tests optionally by suite or test name. There is a parallel test driver (plascom2\+\_\+parallel\+\_\+test) and a serial test driver (plascom2\+\_\+test). Each of these drivers instantiate a Plas\+Com2 Testing Object and drive it to run the tests.\hypertarget{testing_reference_functions}{}\subsection{Testing Functions}\label{testing_reference_functions}
The Testing Functions are those functions that the Plas\+Com2 Testing Object calls from its member methods that implement the tests. The user writes these Testing Functions. Testing Functions must be {\itshape void}. Each Testing Function needs to be added to the testing prototypes in Testing/include/\+External\+Testing\+Functions.\+H and a Plas\+Com2 Testing Object member method added in Testing/include/\+Plas\+Com2\+Test.\+H to call the Testing Function.\hypertarget{testing_reference_suites}{}\subsection{Test Suites}\label{testing_reference_suites}
Test Suites are collections of Tests. Every Test belongs to a Suite. The testing framework executes each Test Suite in-\/turn when the user invokes \textquotesingle{}make test\textquotesingle{}. See \hyperlink{testing_reference_addsuite}{Adding Suites} for how to add new suites to the testing framework.\hypertarget{testing_reference_tests}{}\subsection{Tests}\label{testing_reference_tests}
Tests are defined, from the testing framework\textquotesingle{}s perspective, as a call to \char`\"{}\+Update\+Results\char`\"{} method of the ix\+::test\+::results object. The arguments to Update\+Results indicate the \char`\"{}\+Suite\+Name\char`\"{} and the \char`\"{}\+Test\+Name\char`\"{} for the test\+:

\begin{quote}
results.\+Update\+Results(\char`\"{}$<$\+Suite\+Name$>$\+:$<$\+Test\+Name$>$\char`\"{}); \end{quote}



\begin{DoxyItemize}
\item The \char`\"{}\+Test\+Name\char`\"{} is arbitrary, user-\/defined
\item The \char`\"{}\+Suite\+Name\char`\"{} should be an existing suite -\/\+O\+R-\/ see addsuites
\end{DoxyItemize}

The results for every named test will be reported by C\+Test when the user invokes\+: \begin{quote}
make test \end{quote}
\hypertarget{testing_reference_platforms}{}\subsection{Platform Drivers}\label{testing_reference_platforms}
Platform drivers are scripts that help the tests navigate the resource management system (e.\+g. batch queue) for each platform. Users do not typically need to tinker with these, but mostly they can be found in Testing/\+Platforms\hypertarget{testing_reference_cmake}{}\subsection{C\+Make/\+C\+Test}\label{testing_reference_cmake}
C\+Make/\+C\+Test -\/ the Plas\+Com2 testing framework (currently) uses C\+Make to help parse and prune the lists of tests to run for any given configuration. C\+Test is used to run the tests and report the results on all platforms. 