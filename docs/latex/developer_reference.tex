The intent of this page is to provide some useful information about commonly used data structures and constructs in a centralized quick-\/reference.\hypertarget{developer_reference_config}{}\section{Configuration Object}\label{developer_reference_config}
Plas\+Com2 makes extensive use of a so-\/called {\itshape Configuration Object} which encapsulates user options and other information and makes it available far-\/and-\/wide to the code. The main configuration object (plascom2\+::application\+::app\+Config) gets populated at application configuration time from (plascom2\+::application\+::\+Configure\+Application). The configuration object type is essentially an (ix\+::util\+::\+Parameters) object which is just a collection of Key/\+Value pairs. Once populated, the configuration object is available to all processors at the top level of Plas\+Com2 scope.

If the user specified a configuration file on the command line (i.\+e. with the -\/c $<${\itshape Config\+File}$>$ option), then that file is read into the configuration object. For restarts, the configuration object may be populated from the H\+D\+F5 restart file. Otherwise, not specifying a configuration will invoke {\itshape Bare\+Bones} mode and no simulation will be performed.

If the specified configuration is a legacy file (e.\+g. plascomcm.\+inp), then the configuration is translated into a Plas\+Com2-\/style configuration. The legacy part of the configuration is retained, but not used by Plas\+Com2.\hypertarget{developer_reference_configfile}{}\subsection{Configuration Files}\label{developer_reference_configfile}
The accepted format for configuration file lines is identical between Plas\+Com2 and Plas\+Com\+CM. It is essentially\+:~\newline
 \begin{quote}
Key = Value ~\newline
\end{quote}


The primitive datatype is std\+::string for both {\itshape Key} and {\itshape Value}. The {\itshape Value} is read in as everything (excepting leading and trailing whitespace) that follows the "=" character until the end-\/of-\/line or a comment character, whichever comes first. Comments are started with the "\#" character and anything between the comment character and the end-\/of-\/line is ignored. Lines beginning with comment characters are ignored.

The Plas\+Com2 configuration file format differs from the legacy Plas\+Com\+CM {\itshape inp} format in that it supports the configuration of multiple simulation constructs (e.\+g. domains, grids, boundaries) through the use of {\itshape configuration scope specifyers}. Configuration scope is indicated through the {\itshape Key} with a "$<$Scope\+Name$>$\+:" format. For example the configuration line\+: ~\newline
\begin{quote}
Grid1\+:Grid\+Type = Curvlinear \# grid is a general curvilinear grid~\newline
\end{quote}


In the above configuration line, the {\itshape Key} is "Grid1\+:Grid\+Type", the {\itshape Value} is "Curvilinear", and everything after the "\#" is a comment. The {\itshape Key} indicates {\itshape Grid1} scope. Other grid configurations may be present in the configuration, and they will all have a "Grid\+Type" entry, but each will have its own scope. Everything that comes before the last "\+:" character is considered as a scope specification.

Plas\+Com2 configuration files can also be nested. Two forms of nesting are supported, {\itshape composition}, and {\itshape inheritance}.\hypertarget{developer_reference_configcomposition}{}\subsubsection{Composition}\label{developer_reference_configcomposition}
Composition nesting for configuration files is achieved with the {\itshape Config\+File} keyword. For example\+:~\newline
 \begin{quote}
X\+X\+X\+:\+Y\+YY\+:Config\+File = Some\+Other\+File.\+config~\newline
\end{quote}


Any configuration Key that ends with the Config\+File keyword will cause the configuration utility to find "Some\+Other\+File.\+config" in a relative path and include it (i.\+e. the parameters it contains) in the configuration object.\hypertarget{developer_reference_configinheritance}{}\subsubsection{Inheritance}\label{developer_reference_configinheritance}
Inheritance nesting is accomplished with the {\itshape Sub\+Config\+File} keyword. Sub\+Config\+Files cause the file specified by the value of the configuration key to be parsed in a way that {\itshape inherits} the parent scope. For example\+:~\newline
 \begin{quote}
X\+X\+X\+:\+Y\+YY\+:Sub\+Config\+File = Some\+Other\+File.\+config~\newline
\end{quote}


Using the Sub\+Config\+File keyword causes all parameters read from Some\+Other\+File.\+config to inherit the X\+XX scope. Any subsequent Sub\+Config\+File parameters will also inherit the parent scope.\hypertarget{developer_reference_configkey}{}\subsection{Configuration Keys}\label{developer_reference_configkey}
\hypertarget{developer_reference_configvalue}{}\subsection{Configuration Values}\label{developer_reference_configvalue}
\hypertarget{developer_reference_state}{}\section{State Object}\label{developer_reference_state}
The Plas\+Com2 {\itshape State Object} (plascom2\+::simulation\+::state\+::base) centralizes and encapsulates all of the so-\/called heavy data of a given simulation. It inherits from the primitive field data type (pcpp\+::fielddata\+::dataset).\hypertarget{developer_reference_metadata}{}\subsection{Field Meta\+Data}\label{developer_reference_metadata}
\hypertarget{developer_reference_dictionary}{}\subsection{Data Dictionary}\label{developer_reference_dictionary}
\hypertarget{developer_reference_interval}{}\section{Interval Object}\label{developer_reference_interval}
Information about grids, their domain decomposition, grid regions and sub-\/regions are stored in a {\itshape Plas\+Com2} data structure called an {\itshape interval}. The data type for the interval is ix\+::util\+::sizeextent. What the intervals do and how to use them is best illustrated by example. The following describes an example that is implemented in the Test\+Partition\+Intervals() function in the file Test\+Intervals.\+C.

Example\+: Consider a logically rectangular domain (D) represented by the \char`\"{}interval\char`\"{}\+:

\begin{quote}
(D) = \{1\+:NI,1\+:NJ,1\+:NK\} \end{quote}




Also define rectangular \char`\"{}region of interest\char`\"{} in the domain (D) represented by the \char`\"{}probe interval\char`\"{} (R). The probe interval (R) is a sub-\/region of the global domain (D), and is specified as a subset of (D)\+:

\begin{quote}
(R) = \{i1\+:i2,j1\+:j2,k1\+:k2\}. \end{quote}


Assume (D) has been decomposed into some number of logically rectangular non-\/overlapping partitions and distributed among processes, i.\+e. so that each process \char`\"{}owns\char`\"{} a partition or a rectangular subregion of (D). The rectangular subregion (a.\+k.\+a. the partition) is represented by the interval (L), and each processor\textquotesingle{}s locally-\/owned piece of the domain has the local partition interval\+:

\begin{quote}
(L) = \{li1\+:li2,lj1\+:lj2,lk1\+:lk2\}. \end{quote}




The size of each partition is (nI x nJ x nK) where\+:


\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} li1,li2,lj1,lj2,lk1,lk2; \textcolor{comment}{// set by decomposition}
\textcolor{keywordtype}{size\_t} nI = (li2 - li1) + 1;  
\textcolor{keywordtype}{size\_t} nJ = (lj2 - lj1) + 1;  
\textcolor{keywordtype}{size\_t} nK = (lk2 - lk1) + 1; 
\end{DoxyCode}


The parallel application process will typically create a buffer that is larger than the partition in order to encapsulate a number of {\itshape halo} points who\textquotesingle{}s data will be filled by communication with remote partitions. If the halo is (nH) points wide, then a buffer of size (n\+Bi x n\+Bj x n\+Bk) is required to store data on each point of the partition and its halos, where on each process the required buffer size is\+:


\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} nH;               \textcolor{comment}{// halo size}
\textcolor{keywordtype}{size\_t} nI,nJ,nK;         \textcolor{comment}{// from above}
\textcolor{keywordtype}{size\_t} nBi = (nI + 2*nH);
\textcolor{keywordtype}{size\_t} nBj = (nJ + 2*nH);
\textcolor{keywordtype}{size\_t} nBk = (nK + 2*nH);
\end{DoxyCode}


This buffer size covers both your partition and the halo points on either side of the partition. Let (B) be the buffer interval\+:

\begin{quote}
(B) = \{1\+:n\+Bi,1\+:n\+Bj,1\+:n\+Bk\} \end{quote}




The interval for (L) is called the \char`\"{}partition interval\char`\"{}; it\textquotesingle{}s coordinates are with respect to the non-\/partitioned domain (D). That is, it has I\+JK values (aka coordinates) that are wrt the global, non-\/partitioned domain (D). The local buffer points corresponding to the points of your local partition interval (L) are referred to as the \char`\"{}partition buffer interval\char`\"{} (P\+BI). In this case with halos all around, the (P\+BI) is this interval\+:

\begin{quote}
(P\+BI) = \{n\+H+1\+:n\+H+nI,n\+H+1\+:n\+H+1\+:n\+H+nJ,n\+H+1\+:n\+H+nK\} \end{quote}
\hypertarget{developer_reference_creation}{}\subsection{Creating interval objects}\label{developer_reference_creation}
All of these \char`\"{}intervals\char`\"{} (R), (D), (L), (B) and (P\+BI) are represented by ix\+::util\+::sizeextent objects. They can be created by the following code\+:


\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} domainSizes[]           = \{NI,NJ,NK\}; 
\textcolor{keywordtype}{size\_t} \hyperlink{MetricKernels_8H_af0ac147fcc3cf0ebf0ce192160b920b2}{bufferSizes}[]           = \{nBi,nBj,nBk\};
\textcolor{keywordtype}{size\_t} flatPartitionInterval[] = \{li1,li2,lj1,lj2,lk1,lk2\};
\textcolor{keywordtype}{size\_t} flatProbeInterval[]     = \{i1,i2,j1,j2,k1,k2\};      
\textcolor{keywordtype}{size\_t} flatPartBuffInterval[]  = \{nH+1,nH+nI,nH+1,nH+nJ,nH+1,nH+nK\};
                                                                    
ix::util::sizeextent domainInterval, \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};                
domainInterval.InitSimple(3,domainSizes);           \textcolor{comment}{// (D)                    }
domainInterval.Fortranslate();                      \textcolor{comment}{// use 1-based indices              }
bufferInterval.InitSimple(3,bufferSizes);           \textcolor{comment}{// (B)                    }
bufferInterval.Fortranslate();                                      
                                                                    
ix::util::sizeextent probeInterval(flatProbeInterval,3);              \textcolor{comment}{// (R) }
ix::util::sizeextent partitionInterval(flatPartitionInterval,3);      \textcolor{comment}{// (L) }
ix::util::sizeextent partitionBufferInterval(flatPartBuffInterval,3); \textcolor{comment}{// (PBI)}
\end{DoxyCode}


\begin{DoxyNote}{Note}
Fortranslate is not needed by (R),(L),(P\+BI) -\/ these were explicitly created by initializing with 1-\/based static intervals.
\end{DoxyNote}
The capabilities of the interval datatype (i.\+e. ix\+::util\+::sizeextent) are demonstrated by answering these questions about the domain and region of interest\+:


\begin{DoxyEnumerate}
\item What portion of the global probe interval (R) is located on the local partition?
\item What is the interval of the local buffer that corresponds to the locally owned part of (R)?
\item What are the buffer indices that correspond to the local probe points?
\item Given a local buffer index (l0)\+:
\begin{DoxyEnumerate}
\item what are the point\textquotesingle{}s I\+JK coordinates wrt the local buffer (B)?
\item is the point in the halo or in the partition?
\item what are the point\textquotesingle{}s I\+JK coordinates wrt the global domain (D)?
\item is the point within the region of interest (R)?
\end{DoxyEnumerate}
\end{DoxyEnumerate}\hypertarget{developer_reference_overlap}{}\subsection{Detecting overlap or collision of intervals}\label{developer_reference_overlap}
\subsubsection*{Question 1) What portion of the global probe interval (R) is located on the local partition?}

We need the extent to which (R) overlaps with (L), which we can get with the member function ix\+::util\+::sizeextent\+::\+Overlap. Here\textquotesingle{}s how\+:


\begin{DoxyCode}
ix::util::sizeextent partitionInterval; \textcolor{comment}{// from above}
ix::util::sizeextent probeInterval;     \textcolor{comment}{// from above }
ix::util::sizeextent probePartitionInterval(partitionInterval.Overlap(probeInterval)); 
\end{DoxyCode}


{\itshape OR}


\begin{DoxyCode}
ix::util::sizeextent partitionInterval; \textcolor{comment}{// from above}
ix::util::sizeextent probeInterval;     \textcolor{comment}{// from above }
ix::util::sizeextent probePartitionInterval = partitionInterval.Overlap(probeInterval);            
\end{DoxyCode}


{\itshape OR}


\begin{DoxyCode}
ix::util::sizeextent partitionInterval; \textcolor{comment}{// from above}
ix::util::sizeextent probeInterval;     \textcolor{comment}{// from above }
ix::util::sizeextent probePartitionInterval;                                           
partitionInterval.Overlap(probeInterval,probePartitionInterval);            
\end{DoxyCode}




Now (probe\+Partition\+Interval) is the part of the probe interval (R) that is owned locally.\hypertarget{developer_reference_translation}{}\subsection{Relative translation of intervals}\label{developer_reference_translation}
\subsubsection*{Question 2) What is the interval of my local buffer that corresponds to the locally-\/owned part of (R)?}

The local probe interval (probe\+Partition\+Interval) needs to be translated to line up with the storage buffer that includes the halo regions. That translation can be done with the member function ix\+::util\+::sizeextent\+::\+Relative\+Translation\+:


\begin{DoxyCode}
ix::util::sizeextent probePartitionInterval;  \textcolor{comment}{// from above}
ix::util::sizeextent partitionBufferInterval; \textcolor{comment}{// from above}
ix::util::sizeextent partitionInterval;       \textcolor{comment}{// from above}
ix::util::sizeextent probeBufferInterval;
probePartitionInterval.RelativeTranslation(partitionInterval,partitionBufferInterval,probeBufferInterval);
\end{DoxyCode}




Now (probe\+Buffer\+Interval) is the {\itshape buffer interval} that corresponds to the locally owned portion of the original probe interval (R). The action of Relative\+Translation is simply to find the offset of (probe\+Partition\+Interval) within (L) or (partition\+Interval) and then translate it to the (P\+BI) or (partition\+Buffer\+Interval) interval.

\hypertarget{developer_reference_indices}{}\subsection{Finding buffer indices for sub-\/intervals}\label{developer_reference_indices}
\subsubsection*{Question 3) What are the buffer indices that correspond to the local probe points?}

These are the buffer indices that correspond to the (probe\+Buffer\+Interval) interval. To get a vector of buffer indices that correspond to a sub-\/interval (e.\+g. the probe interval (probe\+Buffer\+Interval) in this case), use ix\+::util\+::sizeextent\+::\+Get\+Flat\+Indices\+:


\begin{DoxyCode}
ix::util::sizeextent \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};      \textcolor{comment}{// from above}
ix::util::sizeextent probeBufferInterval; \textcolor{comment}{// from above}
std::vector<size\_t> probeBufferIndices;
bufferInterval.GetFlatIndices(probeBufferInterval,probeBufferIndices);
\end{DoxyCode}


Now probe\+Buffer\+Indices vector contains the buffer indices of the locally owned probe points. If one wanted to operate on every local probe point (i.\+e. every locally-\/owned point in the region-\/of-\/interest), could do the following\+:


\begin{DoxyCode}
ix::util::sizeextent \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};    \textcolor{comment}{// from above}
std::vector<size\_t> probeBufferIndices; \textcolor{comment}{// from above}
\textcolor{keywordtype}{size\_t} numPointsBuffer = bufferInterval.NNodes();
std::vector<double> someBuffer(numPointsBuffer,0);
std::vector<size\_t>::iterator probeIndices = probeBufferIndices.begin();
\textcolor{keywordflow}{while}(probeIndices != probeBufferIndices.end())\{                
  \textcolor{keywordtype}{size\_t} bufferIndex = *probeIndices++;                         
  Operate(someBuffer[bufferIndex]);                             
\}                                                                       
\end{DoxyCode}
\hypertarget{developer_reference_mapping}{}\subsection{Mapping coordinates and indices for buffers and intervals}\label{developer_reference_mapping}
\subsubsection*{Question 4) Given a local buffer index (l0)\+:}


\begin{DoxyItemize}
\item (a) what are the point\textquotesingle{}s I\+JK coordinates wrt the local buffer (B)?
\item (b) is the point in the halo or in the partition?
\item (c) what are the point\textquotesingle{}s I\+JK coordinates wrt the global domain (D)?
\item (d) is the point within the region of interest (R)?
\end{DoxyItemize}

\subsubsection*{4a) What are the point\textquotesingle{}s I\+JK coordinates wrt the local buffer (B)?}

Mapping back-\/and-\/forth between l0 and interval-\/based I\+JK can be accomplished by the ix\+::util\+::sizeextent\+::\+Coordinates and ix\+::util\+::sizeextent\+::\+Node\+Index member functions. These functions are demonstrated by the following code\+:


\begin{DoxyCode}
ix::util::sizeextent \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};          \textcolor{comment}{// from above}
ix::util::sizeextent probePartitionInterval;  \textcolor{comment}{// from above}
std::vector<size\_t> probeBufferIndices;       \textcolor{comment}{// from above}
\textcolor{keywordtype}{size\_t} numLocalProbePoints = probePartitionInterval.NNodes();
\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} iProbe = 0;iProbe < numLocalProbePoints;iProbe++)\{
   \textcolor{keywordtype}{size\_t} bufferIndex = probeBufferIndices[iProbe]; \textcolor{comment}{// l0}
   \textcolor{comment}{// Get buffer-IJK (bufferInterval-based numbering) for l0}
   std::vector<size\_t> bufferIJK(bufferInterval.Coordinates(bufferIndex));
   \textcolor{comment}{// Get l0 back from buffer-IJK}
   \textcolor{keywordtype}{size\_t} resolvedBufferIndex = bufferInterval.NodeIndex(bufferIJK);
\}
\end{DoxyCode}


\begin{DoxyNote}{Note}
In this example, l0 is meant to be the 0-\/based index into a buffer holding data on each point of the partition (and halos). The I\+JK coordinates returned by the ix\+::util\+::sizeextent\+::\+Coordinates member function will have the same numbering scheme as the ix\+::util\+::sizeextent itself. That is, if the sizeextent is 1-\/based then the returned I\+JK will be 1-\/based. Similarly, the ix\+::util\+::sizeextent\+::\+Node\+Index member function will expect an input set of I\+JK coordinates consistent with the numbering scheme for the sizeextent, and will return a 0-\/based index that is the buffer index corresponding to the data for the given I\+JK point.
\end{DoxyNote}
\subsubsection*{4b) and 4d) Is a given point l0 in the halo, partition or probe/\+R\+OI?}

Simple queries about whether intervals contain certain points can be done with the ix\+::util\+::sizeextent\+::\+Contains member function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} l0;
ix::util::sizeextent \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};          \textcolor{comment}{// from above}
ix::util::sizeextent partitionBufferInterval; \textcolor{comment}{// from above}
std::vector<size\_t> bufferIJK(bufferInterval.Coordinates(l0));
\textcolor{keywordtype}{bool} pointInPartition = partitionBufferInterval.Contains(bufferIJK);
\textcolor{keywordtype}{bool} pointInHalo      = !pointInPartition;
\textcolor{keywordtype}{bool} pointInProbe     = probeBufferInterval.Contains(bufferIJK);
\end{DoxyCode}


\subsubsection*{4c) What are the point\textquotesingle{}s I\+JK coordinates wrt the global domain (D)?}

The ix\+::util\+::sizeextent\+::\+Relative\+Coordinates and ix\+::util\+::sizeextent\+::\+Translate\+Coordinates member functions are used to map the buffer\textquotesingle{}s I\+JK coordinates to the global domain (D)\+:


\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} l0;
ix::util::sizeextent \hyperlink{SATKernels_8H_a4caa6f5ca62531b8c31e22919f206d68}{bufferInterval};          \textcolor{comment}{// from above}
ix::util::sizeextent partitionBufferInterval; \textcolor{comment}{// from above}
std::vector<size\_t> bufferIJK(bufferInterval.Coordinates(l0));
\textcolor{keywordflow}{if}(partitionBufferInterval.Contains(bufferIJK))\{
  std::vector<size\_t> partitionIJK(bufferIJK);\textcolor{comment}{// copy create}
  partitionBufferInterval.RelativeCoordinates(partitionIJK);
  partitionInterval.TranslateCoordinates(partitionIJK);
  \textcolor{comment}{// partitionIJK is now the IJK coordinates wrt the global}
  \textcolor{comment}{// domain (D).}
\}
\end{DoxyCode}
 