\hypertarget{testingproject_guide_testing_intro}{}\section{Introduction}\label{testingproject_guide_testing_intro}
Testing is part of the X\+P\+A\+CC development process. It is very important that we have a consistent, integrated testing in our codes. General guidelines\+:
\begin{DoxyItemize}
\item We use C\+Make/\+C\+Test/\+C\+Dash for our automated build and test system (A\+B\+A\+TE)
\item Project unit testing should be centralized/encapsulated in a few constructs
\item All applications should return 0 to indicate no errors, or passed test, and non-\/zero otherwise.
\item Project tests should be integrated through C\+Make so that the user can use \char`\"{}make test\char`\"{} to run them
\end{DoxyItemize}\hypertarget{testingproject_guide_testing_constructs_sec}{}\section{Testing with IX}\label{testingproject_guide_testing_constructs_sec}
IX offers facilities designed to assist with code and program testing. IX\textquotesingle{}s testing framework supports serial, and parallel tests, platform specific tests, and complex behavior tests. IX\textquotesingle{}s testing facilities come in the form of coding constructs and utility programs. Both are described below. \hypertarget{testingproject_guide_ix_testing_code}{}\subsection{I\+X Testing Constructs}\label{testingproject_guide_ix_testing_code}
IX offers the following code constructs for implementing testing in project codes\+:
\begin{DoxyItemize}
\item ix\+::util\+::\+Test\+Results
\item ix\+::util\+::\+Testing\+Object
\end{DoxyItemize}

In general, project-\/specific testing objects can inherit from the ix\+::util\+::\+Testing\+Object and implement their own tests as member functions of this derived class. The member methods take an object of type ix\+::util\+::\+Test\+Results (or one that inherits from this class), and populate it with testing results. The results object can be streamed -\/ and so typically these results can be streamed to the screen, to a file, or string for further processing.

The IX testing code constructs are defined in {\ttfamily I\+X/include/\+Testing.\+H} and an example of their use can be found in the ix\+::util\+::\+Test\+Object class. This object implements all the tests for the ix\+::\+Util namespace, and is driven by the ix\+::util\+::\+Util\+Test function. In other words, the ix\+::util\+::\+Util\+Test function implements a command line interface for the ix\+::util\+::\+Test\+Object, which implements all the existing tests for the ix\+::\+Util namespace.

More extensive use of the IX code constructs for testing can be found in the example testing objects for Plas\+Com2, which are implemented in Plas\+Com2\+::\+Testing\+Object and Plas\+Com2\+::\+Parallel\+Testing\+Object. These testing objects use simple test fixture functions from the Plas\+Com2\+::\+Test\+Fixture namespace and are driven by Plas\+Com2\+::\+Test and Plas\+Com2\+::\+Parallel\+Test, respectively.

\begin{DoxyNote}{Note}
A major advantage of encapsulating all tests in a single object is that external entities need only to instantiate your project-\/specific testing object to get access to the project\textquotesingle{}s tests. This greatly reduces the complexity of rolling integrated software products out of code from multiple projects.
\end{DoxyNote}
\hypertarget{testingproject_guide_ix_testing_util}{}\subsection{I\+X Testing Support Utilities}\label{testingproject_guide_ix_testing_util}
IX also offers a couple of utilities to support the running of tests. These utilities and their documentation are\+:
\begin{DoxyItemize}
\item {\itshape runtest} (ix\+::\+Run\+Test)
\item {\itshape testresults} (ix\+::\+Test\+Results)
\end{DoxyItemize}

\subsubsection*{Running complex tests with {\itshape runtest}.}

The {\itshape runtest} utility is designed to be called from the project\textquotesingle{}s C\+Make\+Lists.\+txt cmake configuration file. Its purpose is to run scripted tests where the complexity or platform-\/dependent nature of the test being run precludes its being run as a simple test. The {\itshape runtest} utility can run a single named executable, a list of test from file, or resolve platform-\/specific tests.

Examples of how to use the {\itshape runtest} utility can be found in {\ttfamily Plas\+Com2/\+Testing/\+C\+Make\+Lists.\+txt}, where it is used to run the parallel tests (which must use platform-\/specific parallel job spawning mechanisms), and other platform-\/specific, or complex behavior tests.

\subsubsection*{Checking test results with {\itshape testresults}.}

The {\itshape testresults} utility is designed to extract a particular test result from a test results file with one test result per line. If the test\textquotesingle{}s results are such that it has passed, then {\itshape testresults} returns with a zero exit code, and exits with a non-\/zero error code otherwise.

Examples of how to use the {\itshape testresults} utility can be found in {\ttfamily Plas\+Com2/\+Testing/\+C\+Make\+Lists.\+txt}, where it is used to extract the results of all the tests.\hypertarget{testingproject_guide_putting_it_together}{}\subsection{Putting it all together}\label{testingproject_guide_putting_it_together}
All together, the IX testing facilities provide an end-\/to-\/end framework for running, collecting, and reporting your project\textquotesingle{}s tests and results to C\+Make in such a way that C\+Make\textquotesingle{}s integrated testing facilty, C\+Test, can be leveraged to integrate the tests into the project\textquotesingle{}s build system, automate the tests, and report the test results to a {\itshape testing} dashboard. The testing dashboard is a web-\/based facility which collects and reports test results the test histories. X\+P\+A\+CC uses C\+Dash for its testing dashboard.

The birds-\/eye view of the process for using IX\textquotesingle{}s testing facilities with C\+Make/\+C\+Test goes like this\+:
\begin{DoxyEnumerate}
\item Create a project-\/native testing object (P\+N\+TO) by inheriting from ix\+::util\+::\+Testing\+Object.
\item Implement unit tests as member functions of the P\+N\+TO
\item Write a driver (or a set of drivers) that instantiates your testing object(s), and drives them to produce a ix\+::util\+::\+Test\+Results object with the restults from the testing.
\item I\+N\+C\+L\+U\+D\+E(\+C\+T\+E\+S\+T) in your C\+Make\+Lists.\+txt file.
\item Invoke the test driver(s) with C\+Make\textquotesingle{}s A\+D\+D\+\_\+\+T\+E\+S\+T() construct and store the results in a composite testing results file. If necessary use {\itshape runtest} to invoke the actual test(s).
\item If necessary, use {\itshape testresults} to extract the results of the tests from the composite testing results file and exit with a 0 return code for tests that pass, and a non-\/zero otherwise. This step is also accomplished with C\+Make\textquotesingle{}s A\+D\+D\+\_\+\+T\+E\+S\+T().
\item Configure your project (i.\+e. run cmake), and then run the integrated tests with \char`\"{}make test\char`\"{}.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
The reason it may or may not be necessary to use {\itshape runtest} and {\itshape testresults} in steps (5) and (6) is that your tests may be directly invoked by C\+Make\textquotesingle{}s A\+D\+D\+\_\+\+T\+E\+ST {\bfseries if} the test is a standalone executable that returns 0 if it succeeds, and non-\/zero otherwise.
\end{DoxyNote}
\hypertarget{testingproject_guide_ixpt_testing}{}\section{Testing in the X\+P\+A\+C\+C Project Template}\label{testingproject_guide_ixpt_testing}
Direct examples of using IX Testing for several different kinds of tests are provided in the X\+P\+A\+CC Project Template. The following sections summarize the main gist of each of these examples.\hypertarget{testingproject_guide_ixpt_serial_tests}{}\subsection{Serial Test Examples}\label{testingproject_guide_ixpt_serial_tests}
The X\+P\+A\+CC Project Template has both a standalone serial program example, and several serial unit tests. The unit testing is described below, and discussion of the standalone test is deferred to a later section.

For the serial unit tests, the P\+N\+TO is called Plas\+Com2\+::\+Testing\+Object. This object inherits from ix\+::util\+::\+Testing\+Object as described in Step (1) above. The unit tests are in the Plas\+Com2\+::\+Testing\+Object\textquotesingle{}s member methods as prescribed in Step (2). The simple tests and the code construct that they test are\+:
\begin{DoxyItemize}
\item Plas\+Com2\+::\+Testing\+Object\+::\+Test\+\_\+\+\_\+\+Example\+Function tests Plas\+Com2\+::\+Example\+Function
\item Plas\+Com2\+::\+Testing\+Object\+::\+Test\+\_\+\+\_\+\+Trapezoid\+Quadrature tests Plas\+Com2\+::\+Trapezoid\+Quadrature
\item Plas\+Com2\+::\+Testing\+Object\+::\+Test\+\_\+\+\_\+\+Mid\+Point\+Quadrature tests Plas\+Com2\+::\+Mid\+Point\+Quadrature
\end{DoxyItemize}

The {\itshape plascom2\+\_\+test} command-\/line driver executable, implemented by the Plas\+Com2\+::\+Test function drives the Plas\+Com2\+::\+Testing\+Object by instantiating it, and calling the Plas\+Com2\+::\+Testing\+Object\+::\+Run\+Test (if an explicit test name or list was given) or the Plas\+Com2\+::\+Testing\+Object\+::\+Process method to run all tests. This is Step(3).

Step (4) is trivial, and Step (5) is done with the following line from {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt}\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Run\+Plas\+Com2\+Tests \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/plascom2\+\_\+test -\/o plascom2\+\_\+testresults.\+txt) \end{quote}


This runs all of the Plas\+Com2 tests implemented by the Plas\+Com2\+::\+Testing\+Object, and stores the results in the file {\ttfamily plascom2\+\_\+testresults.\+txt}.

For Step (6), the {\itshape testresults} utility is used to extract the results of each of the tests from {\ttfamily plascom2\+\_\+testresults.\+txt} with the following lines from {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt}\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Example\+Program\+:Works \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Example\+Program\+:Works plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Example\+Function\+:Works \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Example\+Function\+:Works plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Trapezoid\+Quadrature\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Trapezoid\+Quadrature\+:Runs plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Trapezoid\+Quadrature\+:Accurate \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Trapezoid\+Quadrature\+:Accurate plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Trapezoid\+Quadrature\+:Order \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Trapezoid\+Quadrature\+:Order2 plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Mid\+Point\+Quadrature\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Mid\+Point\+Quadrature\+:Runs plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Mid\+Point\+Quadrature\+:Accurate \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Mid\+Point\+Quadrature\+:Accurate plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Mid\+Point\+Quadrature\+:Order \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Mid\+Point\+Quadrature\+:Order2 plascom2\+\_\+testresults.\+txt)~\newline
\end{quote}


In Step (7), users configure Plas\+Com2 and invoke \char`\"{}make test\char`\"{} to run the tests and report the results to stdout.\hypertarget{testingproject_guide_ixpt_parallel_tests}{}\subsection{Parallel Test Examples}\label{testingproject_guide_ixpt_parallel_tests}
The X\+P\+A\+CC Project Template has both a standalone parallel application, {\itshape pepi}, and parallel unit tests. The {\itshape pepi} program computes $\pi$ in parallel by doing parallel quadrature, and the unit tests test the parallel quadrature facility. Both will be discussed in this section.

In this test, the P\+N\+TO is called Plas\+Com2\+::\+Parallel\+Testing\+Object. This object inherits from ix\+::util\+::\+Testing\+Object as described in Step (1) above. The unit tests are in the Plas\+Com2\+::\+Parallel\+Testing\+Object\textquotesingle{}s member methods as prescribed in Step (2). The simple tests and the code construct that they test are\+:
\begin{DoxyItemize}
\item Plas\+Com2\+::\+Parallel\+Testing\+Object\+::\+Test\+\_\+\+\_\+\+Parallel\+Trapezoid\+Quadrature tests Plas\+Com2\+::\+Trapezoid\+Quadrature in parallel
\item Plas\+Com2\+::\+Parallel\+Testing\+Object\+::\+Test\+\_\+\+\_\+\+Parallel\+Mid\+Point\+Quadrature tests Plas\+Com2\+::\+Mid\+Point\+Quadrature in parallel
\end{DoxyItemize}

The {\itshape plascom2\+\_\+parallel\+\_\+test} command-\/line driver executable, implemented by the Plas\+Com2\+::\+Parallel\+Test function drives the Plas\+Com2\+::\+Parallel\+Testing\+Object by instantiating it, and calling the Plas\+Com2\+::\+Parallel\+Testing\+Object\+::\+Run\+Test (if an explicit test name or list was given) or the Plas\+Com2\+::\+Parallel\+Testing\+Object\+::\+Process method to run all tests. This is Step(3).

Step (4) is trivial, and Step (5) for this example is more complicated than that of the serial case. Since this is a parallel test, it must be spawned in parallel using something like {\itshape mpiexec} or {\itshape mpirun}. The parallel application spawning mechanism is platform-\/dependent, and even may need to be done through a batch queueing system.

Due to the platform-\/specific nature of executing parallel applications, Step (5) must be accomplished using the {\itshape runtest} utility. This is done in the following line from {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt}\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Run\+Parallel\+Platform\+Tests \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/runtest -\/p \$\{P\+R\+O\+J\+E\+C\+T\+\_\+\+S\+O\+U\+R\+C\+E\+\_\+\+D\+IR\}/share/\+Platforms/parallel\+\_\+platforms -\/o plascom2\+\_\+testresults.\+txt) \end{quote}


This line gives the {\ttfamily Plas\+Com2/share/\+Platforms/parallel\+\_\+platforms} file as the {\itshape platform} argument to {\itshape runtest}. The parallel\+\_\+platforms file is line-\/based and has the following format on each line\+: \begin{quote}
$<$hostname$>$ $<$path to platform-\/specific test list$>$ \end{quote}
If not given on the command line, the {\itshape runtest} utility will determine the hostname and resolve the list of tests from this file. The platform-\/specific test list should list as many parallel testing scripts as one needs to do on the given platform. For example, see {\ttfamily Plas\+Com2/share/\+Platforms/parallel\+\_\+platforms}, and {\ttfamily Plas\+Com2/share/\+Platforms/xpacc\+\_\+cluster\+\_\+parallel.\+list}. You will see that the list includes two scripts that invoke the parallel tests\+:
\begin{DoxyEnumerate}
\item xpacc\+\_\+cluster\+\_\+parallel\+\_\+test1.\+csh (runs the parallel unit test driver)
\item xpacc\+\_\+cluster\+\_\+parallel\+\_\+test2.\+csh (runs {\itshape pepi})
\end{DoxyEnumerate}

On X\+P\+A\+CC\textquotesingle{}s cluster (xpacc\+\_\+cluster), these tests must be conducted through the batch system. These testing scripts submit the tests to the batch system and report the results. These results are then fed into the {\ttfamily plascom2\+\_\+testsresults.\+txt} file.

Essentially, these scripts submit the jobs to the cluster\textquotesingle{}s queue, and then wait on the results before returning to the calling utility, {\itshape runtest}. For further details on how they do this, see {\ttfamily Plas\+Com2/share/\+Platforms/xpacc\+\_\+cluster\+\_\+parallel\+\_\+test1.\+csh} and {\ttfamily Plas\+Com2/share/\+Platforms/xpacc\+\_\+cluster\+\_\+parallel\+\_\+test2.\+csh}.

Once the {\itshape runtest} utility has returned, then the {\ttfamily plascom2\+\_\+testresults.\+txt} file has been updated with the results from the parallel tests, and, just like for the serial test Step (6), the {\itshape testresults} utility is used to extract the results of each of the tests from {\ttfamily plascom2\+\_\+testresults.\+txt} with the following lines from {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt}\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Example\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults P\+E\+PI\+:Runs plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Example\+:Works \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults P\+E\+PI\+:Works plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Trapezoid\+Quadrature\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Trapezoid\+Quadrature\+:Runs plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Trapezoid\+Quadrature\+:Accurate \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Trapezoid\+Quadrature\+:Accurate plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Trapezoid\+Quadrature\+:Order \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Trapezoid\+Quadrature\+:Order2 plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Trapezoid\+Quadrature\+:Weak\+Scaling \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Trapezoid\+Quadrature\+:Weak\+Scaling plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Trapezoid\+Quadrature\+:Strong\+Scaling \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Trapezoid\+Quadrature\+:Strong\+Scaling plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Mid\+Point\+Quadrature\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Mid\+Point\+Quadrature\+:Runs plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Mid\+Point\+Quadrature\+:Accurate \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Mid\+Point\+Quadrature\+:Accurate plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Mid\+Point\+Quadrature\+:Order \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Mid\+Point\+Quadrature\+:Order2 plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Mid\+Point\+Quadrature\+:Weak\+Scaling \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Mid\+Point\+Quadrature\+:Weak\+Scaling plascom2\+\_\+testresults.\+txt)~\newline
A\+D\+D\+\_\+\+T\+E\+ST(Parallel\+Mid\+Point\+Quadrature\+:Strong\+Scaling \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/testresults Parallel\+Mid\+Point\+Quadrature\+:Strong\+Scaling plascom2\+\_\+testresults.\+txt)~\newline
\end{quote}


In Step (7), users configure Plas\+Com2 and invoke \char`\"{}make test\char`\"{} to run the tests and report the results to stdout.\hypertarget{testingproject_guide_direct_tests}{}\subsection{Direct Test Example}\label{testingproject_guide_direct_tests}
The X\+P\+A\+CC Project Template has one serial example program called {\itshape sep}. The {\itshape sep} program simply copies a file. It is a useful example because it can be directly invoked by C\+Test since {\itshape sep} returns 0 if it succeeds and 1 if not (e.\+g. the input file did not exist or something).

The following line from the {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt} file invokes {\itshape sep} and evaluates whether it succeeded or failed (based solely on its return code)\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Example\+Program\+:Runs \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/sep C\+Make\+Cache.\+txt) \end{quote}


\begin{DoxyNote}{Note}
There is no output file, just a name for the test, and then the command it should run.
\end{DoxyNote}
In order to evaluate whether {\itshape sep} actually did what it was told to do, we need a more complicated facility. In fact, this is done with {\itshape runtest} just like above. The following line from {\ttfamily Plas\+Com2/\+C\+Make\+Lists.\+txt} runs a (number of) script(s) from a list. One of these scripts, namely {\ttfamily Plas\+Com2/share/\+Testing/test\+\_\+scripts/serial\+\_\+tests.\+csh}, actually runs  and checks to make sure it copies a file correctly\+:

\begin{quote}
A\+D\+D\+\_\+\+T\+E\+ST(Run\+Tests \$\{E\+X\+E\+C\+U\+T\+A\+B\+L\+E\+\_\+\+O\+U\+T\+P\+U\+T\+\_\+\+P\+A\+TH\}/runtest -\/l \$\{P\+R\+O\+J\+E\+C\+T\+\_\+\+S\+O\+U\+R\+C\+E\+\_\+\+D\+IR\}/share/\+Testing/test\+\_\+scripts/tests.list -\/o plascom2\+\_\+testresults.\+txt) \end{quote}
\hypertarget{testingproject_guide_direct_use}{}\subsection{Reusing the Examples}\label{testingproject_guide_direct_use}
It is highly recommended to simply reuse the testing examples provided in the X\+P\+A\+CC Project Template when creating your own tests that use this framework.

To reuse the example testing objects, the developer could just remove the existing test functions in the serial testing object Plas\+Com2\+::\+Testing\+Object and the parallel testing object, Plas\+Com2\+::\+Parallel\+Testing\+Object and then implement her own unit tests as member functions of those objects.

The corresponding constructs from the {\ttfamily C\+Make\+Lists.\+txt} file would need to be removed/added as well -\/ and also the scripts invoking the tests, if necessary. The rest of the framework, including the test object drivers would still be valid and should continue to work without modification.

In order to create stand alone tests that utilize scripts users can copy the scripts located in testing/share/\+Testing/test\+\_\+scripts and edit them for their needs. Additionally, they will need to follow the examples shown in testing/\+C\+Make\+Lists.\+txt for calling the standalone tests and add a call for their test. If users are creating a regression test or a \char`\"{}gold standard\char`\"{} test in which they wish to compare saved data to newly generated data a script and example command have been created to help. More information on this regression script is below.\hypertarget{testingproject_guide_gold_standard}{}\subsection{Creating a \char`\"{}gold standard\char`\"{} test}\label{testingproject_guide_gold_standard}
A script is provided to help users in creating a \char`\"{}gold standard\char`\"{} test. The idea behind a \char`\"{}gold standard\char`\"{} test is to have saved output from a previous run of the software, where the solution data or output is known to be accurate. The test will then run the newly compiled version of the software and compare the generated output against the saved data. Located in {\bfseries /testing/share/\+Testing/test\+\_\+scripts} is a script titled regression.\+csh. This script is set up to run a \char`\"{}gold standard\char`\"{} test after a few edits from the user. The places in the file that require editing are marked in the script and are explained below.

1) Input\+Dir=\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+ This entry should have the name of the input data directory, which should be created by the user and placed in testing/share/\+Testing/test\+\_\+data. This directory should house all the necessary input data for running the user\textquotesingle{}s executable. The regression script will copy this directory, navigate into it, and then execute the given command.

2) Outputs=\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+ This entry should contain the names of the generated output files that the user wishes to compare with saved data.

3) Outputs\+Check=\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+ This entry should contain the names of the saved output data files to compare the new output files against. Note that the files are compared using the diff command. Also, the files in Outputs must have a one to one corresponence with the files in Outputs\+Check.

4) Test\+Name=\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+ This entry should contain the name the user wishes to use for the test.

5) The command for running the user\textquotesingle{}s executable should be entered at the appropriate place in the script (the loaction is indicated with a comment). The user can also add any other features to the script that may be specific to a test.

In order to run the test and check the results two lines need to be uncommented and one of them edited in testing/\+C\+Make\+Lists.\+txt. These two lines are present in the testing section and are indicated by Regression\+Test as the test name. The first of these must be uncommented. This line calls the runtest executable which in turn calls the regression.\+csh script. The second instance with Regresion\+Test calls the testresult executable and verifies the output of the regression.\+csh script. This second line must be edited to have the name of the user\textquotesingle{}s test used in 4) above. These names must match exactly or the test will indicate failure even if that is not the case. The location to place the test name is indicated in the file. The regression test should then be ready to run with the other tests.

Note that the regression.\+csh script utilizes an executable called diffdatafiles which is part of IX. This executable works like the Unix diff command but will also compare numbers within a given tolerance. Additionally it can be directed to ignore strings and only compare numbers. Using this command users can compare their numerical output to ensure that the answers are within a certain tolerance and ignore other aspects of a data file that might be unimportant like a time and date stamp. The default written into the script is to compare all output files using only the numbers and comparing within a tolerance of 1.\+0e-\/10. Therefore, diffdatafiles will read in each string from the two data files one at a time. If the strings are in fact numbers it will ensure that the two numbers from each file are within 1.\+0e-\/10 of one another (strings will not be compared). The usage for the diffdatafiles command is shown below so that users may change its arguments and runtime behavior if desired. \begin{DoxyVerb}    diffdatafiles [-hnb] [-v [level] -o <filename> -t [tolerance] ] <file1> <file2> 

    -h,--help
            Print out long version of help and exit.

    -v,--verblevel [level]
            Set the verbosity level. (default = 1)

    -o,--output <filename>
            Set the output file to <filename>. (default = stdout)

    -t,--tolerance [tolerance]
            Set the numerical tolerance for comparing numbers to <tolerance>.
            (The default for the tolerance is 1.0e-12.)
            (The default behavior without -t is to compare numbers as strings.)
            (This flag will automatically force the -b flag to be used.)

    -n,--numbers
            Only compare the numbers in the two files.
            (This flag will automatically force the -t flag to be used.)

    -b,--blank
            Ignore blank space between words (or numbers).

    <file1>
            First file to read in for comparison against file2.

    <file2>
            Second file to read in for comparison against file1.
\end{DoxyVerb}
\hypertarget{testingproject_guide_autotesting_sec}{}\section{Automated Testing}\label{testingproject_guide_autotesting_sec}
The X\+P\+A\+CC Project Template has a couple of utilities designed to assist in understanding and setting up automated testing through \href{http://www.cmake.org/cmake/help/v2.8.8/ctest.html}{\tt C\+Test}. A sort of \char`\"{}quickstart\char`\"{} set of steps for setting up automated testing is as follows\+:
\begin{DoxyEnumerate}
\item Log in to X\+P\+A\+CC\textquotesingle{}s \href{http://xpacc-cluster-hn.csl.illinois.edu/CDash}{\tt C\+Dash} instance and create a new project for your project (if it does not already exist).
\item Make a directory from which to run your automated builds and tests (e.\+g. $\sim$/\+Automated\+Testing).
\item Copy {\ttfamily Plas\+Com2/share/\+Testing/test\+\_\+scripts/ctest/\{automated\+\_\+test\+\_\+script.\+cmake},run\+\_\+automated\+\_\+tests,projects,modules,documentation\} into your testing directory.
\item Edit the projects file to remove the examples and add the projects that you want to test.
\item Modify the environment module file in modules directory for your projects to reflect the desired build environment.
\item Modify the documentation file for your project if you want automatic documentation builds
\item Edit the run\+\_\+automated\+\_\+tests script with your customizations.
\item Test the setup by executing\+: \begin{quote}
{\ttfamily }./run\+\_\+automated\+\_\+tests {\ttfamily }./projects Experimental {\ttfamily $\sim$/\+Automated\+Testing} \end{quote}

\item If everything works OK, then add a cron job to invoke {\itshape run\+\_\+automated\+\_\+tests} at your desired intervals and modes.
\end{DoxyEnumerate}

For Step(1), log into \href{http://xpacc-cluster-hn.csl.illinois.edu/CDash}{\tt C\+Dash} and follow the steps to create a new project. Add yourself as an author, and anyone else that should know about the status of the automated builds/tests.

Steps(2) and (3) are obvious.

In Step(4), it should be noted that the projects file is processed line-\/by-\/line. Each line should indicate the parameters for a single build and test. The expected format for each functional line of projects file is as follows\+:

\begin{quote}
$<$Project Name$>$$\vert$$<$Branch Name$>$$\vert$$<$Branch Path$>$$\vert$$<$Repository Type$>$$\vert$$<$Documentation Target$>$ \end{quote}


Based on the line from the projects file, the testing utilities will automatically try to check out the following branch from either G\+IT or S\+VN with the following command\+:

svn\+: \begin{quote}
{\ttfamily svn} {\ttfamily co} {\ttfamily $<$Branch} Path$>$ {\ttfamily $<$Project} Name$>$\+\_\+$<$Branch Name$>$ \end{quote}


git\+: \begin{quote}
{\ttfamily git} {\ttfamily clone} {\ttfamily $<$Branch} Path$>$ {\ttfamily $<$Project} Name$>$\+\_\+$<$Branch Name$>$ \end{quote}


If the $<$Project Name$>$\+\_\+$<$Branch Name$>$ directory already exists, then C\+Test will simply update from S\+VN if there are changes in the repository. On fresh check-\/outs or updates, C\+Test will (re)configure and (re)build the project and run the tests.

In Step(5), the script automatically loads (and subsequently unloads) an environment module file with the project name (if it exists). The module files should setup up the required build environment and reduce the need for hand editing of the run\+\_\+automated\+\_\+tests script.

In Step(6), the testing framework will build documentation for a project if it is enabled through the C\+Make option B\+U\+I\+L\+D\+\_\+\+D\+O\+C\+U\+M\+E\+N\+T\+A\+T\+I\+ON. The documentation can be installed in either a specified directory to which the user has access or uploaded to a git branch. The latter effectively publishes our documentation to the internet, complete with source code (depending on the Doxygen options enabled). The user should add a file with the name of the project in the documentation directory. The expected format of each functional line is as follows\+:

\begin{quote}
$<$destination$>$$\vert$$<$path$>$$\vert$$<$doc\+\_\+src$>$ \end{quote}


$<$destination$>$ is either local or git $<$path$>$ is either a local path accessible to the user, or a git branch name (typically gh-\/pages) $<$doc\+\_\+src$>$ is the directory for the documentation to be copied to.

The presence of a project specific file will enable building of the documentation specified by the build target in the projects file. Note that the documentation build can be disabled if the user specifies \char`\"{}none\char`\"{} for the documentation target.

To add documentation to github, the user should create a branch named gh-\/pages containing the contents of the html directory created by doxygen.

In Step(7), pay particular attention to the settings of the shell, and to the two optional environment settings, {\ttfamily C\+M\+A\+K\+E\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+P\+A\+TH} and {\ttfamily P\+R\+O\+J\+E\+C\+T\+\_\+\+C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+O\+P\+T\+I\+O\+NS}. These options are passed to C\+Make when C\+Test configures your project(s) for automated build and testing. Ideally, any environment specific options should be handled by the module files to keep the build environment clean for subsequent projects.

For Step(8), make sure to replace \char`\"{}$\sim$/\+Automated\+Testing\char`\"{} with the directory that you created in Step(2). The usage for the {\itshape run\+\_\+automated\+\_\+tests} utility is as follows\+:

\begin{quote}
run\+\_\+automated\+\_\+tests $<$projects file$>$ $<$mode$>$ $<$running directory$>$ \end{quote}


Valid default modes are {\itshape Experimental}, {\itshape Nightly}, and {\itshape Continuous}. The only real difference between Experimental and Nightly is how they are denoted in C\+Dash. Experimental builds can happen at any time, whereas nightly tests are expected to be, well... nightly. Continuous builds are useful for things such as Test Driven Development. Continuous builds do not require cron jobs -\/ but automatically update and build your project according to an interval that you can specify, say every 2 minutes or every 10 minutes for example.

In Step(9), your cron job will (presumably) invoke the nightly build/tests. Assuming you want to to run nightly build and test every night at midnight, say, then your crontab would be\+:

\begin{quote}
00 00 $\ast$ $\ast$ $\ast$ /home/my/\+Automated\+Testing/run\+\_\+automated\+\_\+tests /home/my/\+Automated\+Testing/projects Nightly /home/my/\+Automated\+Testing \end{quote}


In general, the format for the crontab is\+: \begin{quote}
MM HH DD NN W Command \end{quote}
Where MM is the two digit minute, HH the two digit hour (in 24 hour format), DD is date of the month, NN is the month, and W is the day of the week (0-\/6). \char`\"{}\+Command\char`\"{} is the command to be executed.

Once you have all of this working, the building and testing can be more easily customized. The \href{http://www.cmake.org/cmake/help/v2.8.8/ctest.html}{\tt C\+Test Manual} is useful in learning about the ways this process can be customized further. Builds and tests can also be customized or made more specific by editing/tweaking the {\itshape run\+\_\+automated\+\_\+tests} script and cron job(s). 