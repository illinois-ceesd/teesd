#
# Copyright (c) 2020, University of Illinois at Urbana-Champaign, XPACC
# License: MIT, http://opensource.org/licenses/MIT
#
#!/bin/tcsh

if ($#argv == 0) then
  printf "Usage:\n"
  printf "run_automated_tests <project_file> <mode=Experimental|Nightly|Continuous>\n"
  printf "                    <working directory> <specific_project> <continuous_duration>\n"
  printf "                    <continuous_interval>\n"
  printf "\n\n\n"
  printf "<project_file> is the full path to the *project_file* which has the\n"
  printf "               following content and format:\n\n"
  printf " ProjectName|BranchName|Repository|RepoType|ConfigType|DocTarget\n"
  printf "\nWhere ProjectName = the name of the project to build\n"
  printf "      BranchName  = the name of the repository branch\n"
  printf "      Repository  = the path to the source repository\n"
  printf "      RepoType    = type of repository (git|svn)\n"
  printf "      ConfigType  = type of build management (autotools|cmake)\n"
  printf "      DocTarget   = build target to make documentation\n"
  printf "\nExample project line:\n"
  printf "PlasComCM|maint|git@bitbucket.org/xpacc-dev/plascomcm|git|autotools|Doc\n"
  printf "\n\n<working_directory> is the full path to the directory in which to run\n"
  printf "\n<specific_project> (if present) indicates to build a specific project\n"
  printf "\nModes:\n"
  printf "Experimental - any generic build, typically run manually\n"
  printf "Nightly - typically used once a day after hours\n"
  printf "Continuous - for <continuous_duration> seconds, the repository will\n"
  printf "             check for repository updates every <continuous_interval>\n"
  printf "             seconds, triggering re-build and re-test if updated.\n"
  printf "\n"
  exit 0
endif


# set echo

# ===== Initialization and setup =========
set project_file="$1"
set mode="$2"
set rundir="$3"
set specific_test="$4"
set cduration="$5"
set cinterval="$6"
if("${project_file}" == "") then
  printf "No project file specified.\n"
  exit 1
endif
if("${mode}" == "") then
  set mode="Experimental"
endif
if("${rundir}" == "") then
  set rundir=`pwd`
endif
if("${cduration}" == "") then
  setenv CONTINUOUS_DURATION 54000
else
  setenv CONTINUOUS_DURATION ${cduration}
endif
if("${cinterval}" == "") then
  setenv CONTINUOUS_INTERVAL 300
else
  setenv CONTINUOUS_INTERVAL ${cinterval}
endif



set HOSTNAME=`hostname -s`
cd ${rundir}

# Use a different shell or shell config if you want
#source ${HOME}/.tcshrc
#use cmake
if( -d platform_configuration ) then
  foreach user_configuration_file (`ls platform_configuration/*`)
     source ${user_configuration_file}
  end
endif
  
# ========================================

# === Build/Test Environment Settings ====
setenv SVNCOMMAND `which svn`
setenv GITCOMMAND `which git`
setenv CTESTCOMMAND `which ctest`
setenv CMAKECOMMAND `which cmake`
# The following two lines are optional.  Rocpack requires this
# setting for CMAKE_PREFIX_PATH. Your project may require
# different paths, or a whole set of options - which can be
# set as the PROJECT_CONFIGURATION_OPTIONS environment variable.
#setenv MODULEPATHSAV $MODULEPATH
#setenv MODULEPATH "${rundir}/modules:$MODULEPATH"
#
#  add a variable to enable building documentation
#  eventually read this from input
#
#setenv BUILD_DOCUMENTATION "ON"
#setenv PROJECT_CONFIGURATION_OPTIONS "-DBUILD_DOCUMENTATION=ON"

# ========================================

# == Loop over projects and invoke ctest =
foreach project (`cat ${project_file} | grep -v "#"`)
  set PROJECT_NAME=`printf "${project}" | cut -d "|" -f 1`
  set BRANCH_NAME=`printf "${project}" | cut -d "|" -f 2`
  set BRANCH_NAME_SAFE=`printf "${project}" | cut -d "|" -f 2 | sed 's/\//_/g'`
  set BRANCH_PATH=`printf "${project}" | cut -d "|" -f 3`
  if( ("${specific_test}" == "${PROJECT_NAME}") || ("${specific_test}" == "") ) then
    set REPO_TYPE=`printf "${project}" | cut -d "|" -f 4`
    setenv REPO_TYPE ${REPO_TYPE}
    set CONFIG_TYPE=`printf "${project}" | cut -d "|" -f 5`
    setenv PROJECT_CONFIGURATION_TYPE ${CONFIG_TYPE}
    setenv DOC_TARGET `printf "${project}" | cut -d "|" -f 6`

    printf "***************************************************\n"
    printf "Processing ${PROJECT_NAME} ${BRANCH_NAME} on ${HOSTNAME}...\n"
    printf "***************************************************\n"
    printf "Mode: ${mode}\n"
    printf "Top level automated build directory: ${rundir}\n"
    printf "Safe branch name: ${BRANCH_NAME_SAFE}\n"

    setenv TARGET_PROJECT_NAME ${PROJECT_NAME}
    setenv PROJECT_SOURCE "${rundir}/${PROJECT_NAME}_${BRANCH_NAME_SAFE}"
    setenv PROJECT_ROOT ${BRANCH_PATH}
    # check for user defined build directory
    if ($?BUILD_DIRECTORY) then
      setenv PROJECT_BUILD_DIRECTORY "${BUILD_DIRECTORY}/${PROJECT_NAME}-${HOSTNAME}-${BRANCH_NAME_SAFE}-${mode}"
      `ln -s $PROJECT_BUILD_DIRECTORY ${PROJECT_NAME}-${HOSTNAME}-${BRANCH_NAME_SAFE}-${mode}-Build`
    else
      setenv PROJECT_BUILD_DIRECTORY "${rundir}/${PROJECT_NAME}-${HOSTNAME}-${BRANCH_NAME_SAFE}-${mode}"
    endif
    setenv BRANCH ${BRANCH_NAME}
    setenv BRANCHTAG ${BRANCH_NAME_SAFE}

    printf "PROJECT_NAME = ${PROJECT_NAME}\n"
    printf "PROJECT_SOURCE = ${PROJECT_SOURCE}\n"
    printf "PROJECT_ROOT = ${PROJECT_ROOT}\n"
    printf "PROJECT_BUILD_DIRECTORY = ${PROJECT_BUILD_DIRECTORY}\n"
    printf "BRANCH = ${BRANCH}\n"
    if("${mode}" == "Continuous") then
      printf "Continuous Interval:  ${CONTINUOUS_INTERVAL}(s)\n"
      printf "Continuous Duraction: ${CONTINUOUS_DURATION}(s)\n"
    endif


    # load project specific environment module
    unsetenv PROJECT_BUILD_TAG
    if (-e modules/${PROJECT_NAME}) then
      printf "Loading module ${PROJECT_NAME}\n"
      module load ${PROJECT_NAME}
    endif

    # source any project-specific configuration
    setenv PROJECT_CONFIGURATION_OPTIONS 
    if(-e project_configuration/${PROJECT_NAME}) then
      printf "Setting ${PROJECT_NAME}-specific configuration.\n"
      source project_configuration/${PROJECT_NAME}
    endif

    # look for the project in the documentation directory, this indicates we should
    # build the documentation
    unsetenv BUILD_DOCS
    if ( (-e documentation/${PROJECT_NAME}) && (${DOC_TARGET} != "none") ) then
      setenv PROJECT_CONFIGURATION_OPTIONS "-DBUILD_DOCUMENTATION=ON ${PROJECT_CONFIGURATION_OPTIONS}" 
      printf "Enabling documentation build for ${PROJECT_NAME}\n"
      setenv BUILD_DOCS TRUE
    endif

    set LOGFILE = ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_log.txt
    if( ! -e ${LOGFILE}) then
      touch ${LOGFILE}
    endif
    printf "****************************\n\n\n" >> ${LOGFILE}
    date >> ${LOGFILE}
    printf "** ** ** ** ** ** ** ** ** *\n" >> ${LOGFILE}
    printf "Build Environment:\n" >> ${LOGFILE}
    env >> ${LOGFILE}
    printf "** ** ** ** ** ** ** ** ** *\n" >> ${LOGFILE}
    printf "Running ctest for ${PROJECT_NAME}\n"
    if("${mode}" == "Continuous") then
      rm -f ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_continuousLog.txt
      ctest -S ./automated_test_script.cmake,Continuous -V >& ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_continuousLog.txt &
      printf "Done spawning continuous testing.\n"
    else
      rm -f ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_temp_log.txt
      ctest -S ./automated_test_script.cmake,${mode} -V >& ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_temp_log.txt
      cat ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_temp_log.txt >> ${LOGFILE}
      rm -f ${PROJECT_NAME}_${BRANCH_NAME_SAFE}_${mode}_temp_log.txt
      # something is broken with scp submission from ctest
      # force a manual submission if CTEST_DROP_METHOD=scp
      if ($?CTEST_DROP_METHOD) then
        if ("${CTEST_DROP_METHOD}" == "scp") then
          printf "Manual test submission via scp \n"
          cd ${PROJECT_BUILD_DIRECTORY}
          ctest -T submit
          cd -
        endif
      endif
      printf "Done running ctest for ${PROJECT_NAME} \n"
    endif 

    if("${mode}" != "Continuous") then

      # we have built the documentation, now do something with it
      # the loop allows us to specify multiple destinations for the same project
      if (-e documentation/${PROJECT_NAME}) then
        foreach document (`cat documentation/${PROJECT_NAME} | grep -v "#"`)
          set DOC_DEST=`printf "${document}" | cut -d "|" -f 1`
          set DOC_PATH=`printf "${document}" | cut -d "|" -f 2`
          set DOC_SRC=`printf "${document}" | cut -d "|" -f 3`

          if( "${DOC_DEST}" == "local" ) then
            if (! -e ${DOC_PATH}) then
              mkdir -p ${DOC_PATH}
            endif

            # the documentation can be a lot of files, exceeding the limit of glob
            # instead of a straight copy we do things one file at a time
            # still do a recursive copy of the directories, assuming they do not 
            # contain massive amounts of files
            set files = `ls ${PROJECT_BUILD_DIRECTORY}/${DOC_SRC}`
            foreach file (`echo ${files}`)
              # this is recursive in case the file is a directory
              cp -R ${PROJECT_BUILD_DIRECTORY}/${DOC_SRC}/$file ${DOC_PATH}/.
            end
          else if ( "${DOC_DEST}" == "git" ) then
            printf "Updating git documentation for ${PROJECT_NAME}\n"
            if (-e ${PROJECT_NAME}_${DOC_PATH}) then
              rm -Rf ${PROJECT_NAME}_${DOC_PATH}
            endif
            ${GITCOMMAND} clone -b ${DOC_PATH} --recursive ${PROJECT_ROOT} ${PROJECT_NAME}_${DOC_PATH}
            cd ${PROJECT_NAME}_${DOC_PATH}

            set files = `ls`
            foreach file (`echo ${files}`)
              # this is recursive in case the file is a directory
              rm -R $file
            end

            set files = `ls ${PROJECT_BUILD_DIRECTORY}/${DOC_SRC}`
            foreach file (`echo ${files}`)
              # this is recursive in case the file is a directory
              cp -R ${PROJECT_BUILD_DIRECTORY}/${DOC_SRC}/$file .
            ${GITCOMMAND} add $file
            end

            ${GITCOMMAND} commit -a -m "Automated documentation update" 
            ${GITCOMMAND} push origin ${DOC_PATH}
            cd ..
          else
            printf "Unknown document destination ${DOC_DEST} for project ${PROJECT_NAME}\n"
          endif
        end
      endif
    endif

    # unload project specific environment module
    if (-e modules/${PROJECT_NAME}) then
      module unload ${PROJECT_NAME}
    endif

    # undo project-specific environment
    if (-e configuration/${PROJECT_NAME}.unconfig) then
      source configuration/${PROJECT_NAME}.unconfig
    endif

  endif
end

#reset environment
#setenv MODULEPATH $MODULEPATHSAV
# ========================================


